<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Python2笔记--类 - CaptainChen</title>
<link rel="shortcut icon" href="https://wizyoung.github.io/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://wizyoung.github.io/media/css/tailwind.css">
<link rel="stylesheet" href="/media/css/font-awesome.min.css">
<link rel="stylesheet" href="/media/css/align.css">
<link rel="stylesheet" href="https://wizyoung.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Python2笔记--类 - CaptainChen - Atom Feed" href="https://wizyoung.github.io/atom.xml">

<script async type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script type='text/javascript' src='https://platform-api.sharethis.com/js/sharethis.js#property=5d74f9d2ab6f1000123c83b9&product=inline-share-buttons' async='async'></script>


  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90329290-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-90329290-1');
  </script>
    

  <meta name="description" content="Python面向对象特性中最核心的一部分就是类了，花了点时间整理了一下，做成笔记，方便日后翻阅。
1. 新式类(object类)和旧式类
1.1 定义

旧式类：

定义一个旧式类A:

class A:
    pass

实例化:
a ..." />
  <meta property="og:title" content="Python2笔记--类 - CaptainChen">
  <meta property="og:description" content="Python面向对象特性中最核心的一部分就是类了，花了点时间整理了一下，做成笔记，方便日后翻阅。
1. 新式类(object类)和旧式类
1.1 定义

旧式类：

定义一个旧式类A:

class A:
    pass

实例化:
a ..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://wizyoung.github.io/Python2笔记-类/" />
  <meta property="og:image" content="https://wizyoung.github.io/images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="Python2笔记--类 - CaptainChen">
  <meta name="twitter:description" content="Python面向对象特性中最核心的一部分就是类了，花了点时间整理了一下，做成笔记，方便日后翻阅。
1. 新式类(object类)和旧式类
1.1 定义

旧式类：

定义一个旧式类A:

class A:
    pass

实例化:
a ...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://wizyoung.github.io/Python2笔记-类/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://wizyoung.github.io/media/css/prism-material-oceanic.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://wizyoung.github.io" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      CaptainChen
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          Python2笔记--类
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">
            <i class="fa fa-calendar"></i>  2017-01-24
            <span style="margin-right:8px"></span>
            <i class="fa fa-clock-o"></i>  7043 words (about 31 min read)
            <!-- <span style="margin-right:8px"></span>
            <i class="fa fa-file-word-o"></i>  7043 words -->
            <span style="margin-right:8px"></span>
            <i class="fa fa-eye"></i>  <span class="date_info"><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> Views
</span>
          </div>
            
            <script>
              function lan(){
                if (document.getElementById("lan").innerText == "简→繁"){
                  var s=document.getElementById("tongwenlet_cn");
                  if(s != null){
                  document.body.removeChild(s);
                  }
                  var s = document.createElement("script");
                  s.language = "javascript";
                  s.type = "text/javascript";
                  s.src = "https://git.oschina.net/runningcheese/JiathisQR.js/raw/master/bookmarklet_tw.js";
                  s.id = "tongwenlet_cn";
                  document.body.appendChild(s);
                  document.getElementById("lan").innerHTML = "繁→簡"
                }
                else if(document.getElementById("lan").innerText == "繁→簡"){
                  var s=document.getElementById("tongwenlet_cn");
                  if(s != null){
                  document.body.removeChild(s);
                  }
                  var s = document.createElement("script");
                  s.language = "javascript";
                  s.type = "text/javascript";
                  s.src = "https://git.oschina.net/runningcheese/JiathisQR.js/raw/master/bookmarklet_cn.js";
                  s.id = "tongwenlet_cn";
                  document.body.appendChild(s);
                  document.getElementById("lan").innerHTML = "简→繁"
                  }
              }
            </script>
          <div class="text-gray-400 text-sm mr-4">
            <i class="fa fa-refresh"></i>  <a id="lan" href="javascript:void(0);" onclick="lan();" title="调整简繁体">简→繁</a>
          </div>
          
            <a href="https://wizyoung.github.io/tag/E1T5P6edB/" class="text-gray-500 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              Python
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <p>Python面向对象特性中最核心的一部分就是类了，花了点时间整理了一下，做成笔记，方便日后翻阅。</p>
<h2 id="1-新式类object类和旧式类">1. 新式类(object类)和旧式类</h2>
<h3 id="11-定义">1.1 定义</h3>
<ul>
<li>旧式类：</li>
</ul>
<p>定义一个旧式类A:</p>
<!-- more -->
<pre><code class="language-python">class A:
    pass
</code></pre>
<p>实例化:</p>
<pre><code class="language-python">a = A()
</code></pre>
<ul>
<li>新式类：</li>
</ul>
<p>定义一个新式类B:</p>
<p><strong>方法一</strong>：</p>
<pre><code class="language-python">class B(object):  # B类继承object类，括号表示继承关系
    pass          # 在Python3中所有的类都默认为新式类，不需要再显式指定了
</code></pre>
<p><strong>方法二：</strong></p>
<p>在类的前面加上一句<code>__metaclass__ = type</code>，就不需要在类名字后面加上<code>(object)</code>了：</p>
<pre><code class="language-python">__metaclass__ = type
class B:
    pass
</code></pre>
<h3 id="12-区别">1.2 区别</h3>
<p>在Python中，万物皆对象。因此，类也有类，类的类叫<strong>元类</strong>（这里强调的是实例化过程）。</p>
<ul>
<li>在旧式类中，类源自于<code>classobj</code>，类的实例则源自于<code>instance</code>。对旧式类的实例<code>x</code>，<code>x.__class__</code>查看的才是它对应的类，但<code>type(x)</code>查看的结果永远是<code>&lt;type 'instance'&gt;</code></li>
</ul>
<pre><code class="language-python">class C():
    pass
c = C()
print type(C)  # &lt;type 'classobj'&gt;
print type(c)  # &lt;type 'instance'&gt;

print C  # __main__.C
print c  # &lt;__main__.C instance at 0x101dfd050&gt;
print c.__class__  # __main__.C
</code></pre>
<ul>
<li>引入新式类的目的是为了用<code>元类</code>来构造类对象，统一类的模型。在新式类中，所有的类都继承自<code>object</code>，都是<code>type</code>的实例。新式类才是真正的类。在新式类中，<code>x.__class__</code>和<code>type(x)</code>的结果是一样的（它们强调的都是实例化关系）。在新式类中，<strong>一般</strong>类的元类是type类（因此指定了<code>__metaclass__ = type</code>的类就是新式类，继承自<code>object</code>)。</li>
</ul>
<pre><code class="language-python">class CC(object):
    pass
cc = CC()
print type(CC)  # &lt;type 'type'&gt;
print type(cc)  # &lt;class '__main__.CC'&gt;

print CC  # &lt;class '__main__.CC'&gt;
print cc  # &lt;__main__.CC object at 0x10f7aa290&gt;
print cc.__class__  # &lt;class '__main__.CC'&gt;
</code></pre>
<h2 id="2-类和实例">2. 类和实例</h2>
<h3 id="21-self的作用">2.1 self的作用</h3>
<p>举个简单的例子：</p>
<pre><code class="language-python">__metaclass__ = type
class Person:
    def __init__(self, name):
        self.name = name
    def getName(self):
        return self.name
</code></pre>
<p>实例化：</p>
<pre><code class="language-python">girl = Person('chen')
name = girl.getName()
print 'the person's name is: ',name
</code></pre>
<ul>
<li>在类内部，所有的传入数据都赋值给一个变量，这个变量是self。在类中定义的函数的第一个参数都是self，就是起到这个作用—接收实例化过程中传入的所有数据。</li>
<li>self是一个实例，准确来说，是<strong>实例的引用变量</strong>。</li>
<li>在初始化函数<code>__init__</code>中通过<code>self.attribute</code>的方式，规定self实例对象的属性，这个属性也是类实例化对象的属性。</li>
</ul>
<h3 id="22-类属性和实例属性">2.2 类属性和实例属性</h3>
<p>类也是一个对象，它也有属性</p>
<pre><code class="language-python">class A(object):
    x = 7
foo = A()  # 实例化
</code></pre>
<ol>
<li>
<p>在类中，变量x引用的数据可以通过类来直接调用：<code>A.x</code>，这就是<strong>类属性</strong>。</p>
</li>
<li>
<p><code>foo.x</code>叫<strong>实例属性</strong>。</p>
</li>
<li>
<p>对于<strong>不可变数据</strong>，<strong>实例属性无法更改类属性，但是类属性可以更改实例属性</strong>。</p>
<p>解释：这句话表述不太好。对<code>foo.x</code>进行数学运算并不会更改<code>A.x</code>的值。若只是调用<code>foo.x</code>而不对x进行运算等操作，<code>foo.x</code>就<strong>完全</strong>等同于<code>A.x</code>，这里得完全指的是同一个内存地址。一旦对<code>foo.x</code>进行操作，本质是实例foo又建立了一个新的属性x，此时再更改<code>A.x</code>的值就不会影响<code>foo.x</code>了。</p>
</li>
<li>
<p>当类中变量引用的是<strong>可变数据</strong>，情况会有所不同。因为可变数据能进行原地修改。</p>
<p>如：</p>
<pre><code class="language-python">class B(object):
    y = [1,2,3]
bar = B()
</code></pre>
<p>这种情况下B.y和bar.y始终保持<strong>完全等同</strong>。</p>
</li>
</ol>
<h3 id="23-访问限制">2.3 访问限制</h3>
<p>在属性或者方法的名称前面加上两个下划线，即<code>__</code>，即可将之私有化，使不能被外部访问。</p>
<pre><code class="language-python">   class A(object):
       def __init(self, name):
           self.__name = name
</code></pre>
<p>此时尝试从外部访问会出错：</p>
<pre><code class="language-python">   a = A()
   a.__name  # AttributeError: 'A' object has no attribute '__name'
</code></pre>
<p>若要从外部访问或修改私有变量，建议如下操作：</p>
<pre><code class="language-python">   class A(object):
       def __init__(self, name):
           self.__name = name
       
       def get_name(self):
           return self.__name
       
       def set_name(self, name):
           self.__name = name
</code></pre>
<p>之所以是建议，是因为以双下划线开头的变量并不是不能从外部访问。不能从外部访问<code>__name</code>是因为Python解释器对外把<code>__name</code>改成了<code>_A__name</code>。因此，仍然可通过<code>_className__attr</code>的形式访问私有变量。</p>
<p>另外，如果变量名前面只有一个下划线<code>_</code>，表示不要<code>随意访问这个变量</code>，虽然它可以直接被访问。</p>
<h3 id="24-获取对象信息">2.4 获取对象信息</h3>
<p>当我们拿到一个对象，常用的有如下几种方法考察它的类型和方法:</p>
<ul>
<li>
<p>使用<code>type</code></p>
<p>用<code>type(obj)</code>查看对象的类型（为何的实例）：</p>
<pre><code class="language-python">a = A()
print type(a)  # &lt;class '__main__.A'&gt;
</code></pre>
</li>
<li>
<p>使用<code>isinstance</code></p>
<p>使用<code>isinstance(obj, type)</code>判断对象是否为指定的type类型的实例：</p>
<pre><code class="language-python">isinstance(a, A)  # True
</code></pre>
</li>
<li>
<p>使用<code>hasattr/getattr/setattr</code>（这些方法均不能访问私有属性）</p>
<ul>
<li>使用<code>hasattr(obj, attr)</code>判断对象是否具有指定属性/方法；</li>
<li>使用<code>getattr(obj, attr[, default])</code>获取属性/发法的值，若没有找到对应的属性值则返回default值（前提是设置类default），否则会抛出<code>AttributeError</code>异常；</li>
<li>使用<code>setattr(obj, attr, value)</code>设定该属性/方法的值，类似于<code>obj.attr = value</code>;</li>
</ul>
</li>
<li>
<p>使用<code>dir</code></p>
<p>使用<code>dir(obj)</code>可以获取相应对象的<strong>所有</strong>属性和方法名的列表：</p>
<pre><code class="language-python">  class A(object):
      def __init__(self, name, age):
          self.__name = name
          self.age = age

      def get_name(self):
          return self.__name

  a = A('yang', 22)
  print dir(a)
  # ['_A__name', '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'get_name']
</code></pre>
</li>
</ul>
<h2 id="3-命名空间">3. 命名空间</h2>
<p>命名空间分为以下三类：</p>
<ul>
<li>
<p><strong>内置命名空间(Built-in Namespaces)</strong>: Python运行起来，它们就存在。内置函数的命名空间都属于内置命名空间。</p>
</li>
<li>
<p><strong>全局命名空间(Module: Global Namespaces)</strong>: 每个模块创建它的全局命名空间，彼此独立，互不冲突。</p>
</li>
<li>
<p><strong>本地命名空间(Functions&amp;Class: Local Namespaces)</strong>: 每个函数或类定义的空间就是本地命名空间。若函数返回了结果或者抛出异常，则本地命名空间结束。</p>
</li>
</ul>
<pre><code class="language-shell">    程序在查询上述三种命名空间的时候，按照从里到外的顺序，即：Local Namespaces --&gt; Global Namesspaces --&gt; Built-in Namesspaces
</code></pre>
<h2 id="4-继承">4. 继承</h2>
<h3 id="41-基本概念">4.1 基本概念</h3>
<p>继承很简单，注意，如果子类重写了父类的方法，父类的方法就被覆盖。</p>
<h3 id="42-多重继承">4.2 多重继承</h3>
<pre><code class="language-python">class K1(object):
    def foo(self):
        print &quot;K1-foo&quot;

class K2(object):
    def foo(self):
        print &quot;K2-foo&quot;
    def bar(self):
        print &quot;K2-bar&quot;

class J1(K1, K2):
    pass

class J2(K1, K2):
    def bar(self):
        print &quot;J2-bar&quot;

class C(J1, J2):
    pass

if __name__ == &quot;__main__&quot;:
    print C.__mro__  # 打印出类的继承顺序Method Resolution Order
    m = C()
    m.foo()
    m.bar()
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">(&lt;class '__main__.C'&gt;, &lt;class '__main__.J1'&gt;, &lt;class '__main__.J2'&gt;, &lt;class '__main__.K1'&gt;, &lt;class '__main__.K2'&gt;, &lt;type 'object'&gt;)
K1-foo
J2-bar
</code></pre>
<p>搜索顺序：<strong>广度优先</strong>。即C==&gt;J1==&gt;J2==&gt;K1==&gt;K2</p>
<h3 id="43-super函数">4.3 super函数</h3>
<p>1.看例子：</p>
<pre><code class="language-python">__metaclass__ = type
class Base:
    def __init__(self):
        self.a = 1
class Child(Base):
    def __init__(self):
        super(Child, self).__init__()  # 等价于Base.__init__ (self)
        self.b = 2
chen = Child()
print chen.a
</code></pre>
<p>(1) 若子类Child中没有定义<code>__init__</code>函数，则子类的实例chen就从父类的<code>__init__</code>函数中寻找a</p>
<p>(2) 若子类Child定义了<code>__init__</code>函数，但是没有super那一行，就会报错，因为子类重写了父类的<code>__init__</code>方法，父类的<code>__init__</code>方法就被覆盖掉了，因此无变量a</p>
<p>(3) 既要保留父类<code>__init__</code>中的参量又要新添加参量，就可以用super函数。super函数的第一个参数是当前子类的名字，第二个参数是self，然后是点号，后面是要调用的父类的方法</p>
<p>2.重点：<strong>不要一说到 super 就想到父类！super 指的是 MRO 中的下一个类！</strong></p>
<p>例子：</p>
<pre><code class="language-python">class Root(object):
    def __init__(self):
        print(&quot;this is Root&quot;)

class B(Root):
    def __init__(self):
        print(&quot;enter B&quot;)
        super(B, self).__init__()
        print(&quot;leave B&quot;)
        
class C(Root):
    def __init__(self):
        print(&quot;enter C&quot;)
        super(C, self).__init__()
        print(&quot;leave C&quot;)
        
class D(B, C):
    pass
        
d = D()
print(d.__class__.__mro__)
</code></pre>
<p>输出：</p>
<pre><code class="language-shell">enter B
enter C
this is Root
leave C
leave B
(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)
</code></pre>
<p>对于<code>super(B, self).__init__()</code>, 首先，我们获取<code>self.__class__.__mro__</code>，注意这里的self是D的实例而不是B的：<code>(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</code>. 然后通过B来定位MRO中的index，并找到下一个，也就是C，于是调用C的_<em>init</em>_, 打出enter C<br>
因此，<code>super(B, self).__init__()</code>和<code>Root.__init__(self)</code>是不一样的</p>
<p>3.这里我们在回头看看super内部是怎么实现的：</p>
<pre><code class="language-python">def super(cls, inst):
    mro = inst.__class__.mro()
    return mro[mro.index(cls) + 1]
</code></pre>
<p>super内部接收两个参数cls和inst。inst用来确定mro, 然后通过cls来定位mro中当前的index, 并返回mro中下一个值。</p>
<h2 id="5-多态">5. 多态</h2>
<p>有了继承，才能有多态。多态就是指：<strong>不同类型的对象对同一消息会做出不同的响应</strong>。</p>
<p>事实上，我们经常使用到多态：</p>
<pre><code class="language-python">1 + 2      # 3
'a' + 'b'  # 'ab'
</code></pre>
<p>再举一个类的例子：</p>
<pre><code class="language-python">class Animal(object):
    def __init__(self, name):
        self.name = name
    def greet(self):
        print 'Hello, I am %s.' % self.name

class Dog(Animal):
    def greet(self):
        print 'WangWang.., I am %s.' % self.name

class Cat(Animal):
    def greet(self):
        print 'MiaoMiao.., I am %s' % self.name

def hello(animal):
    animal.greet()
</code></pre>
<p>多态的使用：</p>
<pre><code class="language-python">dog = Dog('dog')
hello(dog)  # WangWang..., I am dog.

cat = Cat('cat')
hello(cat)  # MiaoMiao..., I am cat.
</code></pre>
<p>可以看到，<code>cat</code>和<code>dog</code>是两个不同的对象，对它们调用<code>greet</code>方法，它们会自动调用实际类型的<code>greet</code>方法，做出不同的响应，这就是多态。</p>
<h2 id="6-类方法和静态方法">6. 类方法和静态方法</h2>
<p>对一个类，我们要调用它的一个方法，必须要绑定实例，而不能直接通过<code>类名.方法名()</code>的形式调用。因此，想要通过类来调用方法，而不是通过实例，可以使用<strong>静态方法</strong><code>@staticmethod</code>和<strong>类方法</strong><code>@classmethod</code>的形式实现。</p>
<p>二者的形式：</p>
<pre><code class="language-shell">@classmethod修饰的方法的第一个参数必须是cls。cls指的是类的本身，若有继承出现，cls指当前类。
@staticmethod修饰的方法没有self和cls参数，可以不接受参数
</code></pre>
<p>使用情形：</p>
<p>考虑如下的Date类：</p>
<pre><code class="language-python">class Date(object):
    
    day = 0
    month = 0
    year = 0
    
    def __init__(self, day=0, month=0, year=0):
        self.day = day
        self.month = month
        self.year = year
</code></pre>
<p>如果我们有很多非标准格式的<code>day-month-year</code>(如11-09-2012)这样的数据，要将它们解析为Date所能接收的标准格式并创建类的实例该怎么做呢？</p>
<p>正常我们可以在类外添加额外代码处理：</p>
<pre><code class="language-python">day, month, year = map(int, string_data.split('-'))
data1 = Data(day, month, year)
</code></pre>
<p>这样将代码放在类外单独处理，固然可以，但是若能让类本身就能处理这种非标准输入不是更好吗？后者显然维护起来更方便。</p>
<p>用类方法实现如下：</p>
<p>在Date中加入这样一个类方法：</p>
<pre><code class="language-python">@classmethod
def from_string(cls, data_as_string):
    day, month, year = map(int, data_as_string.split('-'))
    rerurn cls(day, month, year)
    
data = Data.from_string('11-09-2012')
</code></pre>
<p>回头看我们的代码，我们将<strong>数据预处理</strong>封装在了类中，这样不仅好维护，没有代码扩散到类外的情况，而且更酷的是其子类也能继承这个类方法，也具有这个特性。</p>
<p>那静态方法呢？</p>
<p>假设有这样一个需求，对输入的数据进行有效性判断，怎么做呢？</p>
<p>再插入这样一个静态方法：</p>
<pre><code class="language-python">@staticmethod
def is_data_valid(data_as_string):
    day, month, year = map(int, data_as_string.split('-'))
    return day &lt;=31 and month &lt;=12 and year &lt;=3999

# usage
is_data = Data.is_data_valid('11-09-2012')
</code></pre>
<p>同样没有进行实例化，直接把预处理封装在了类中。</p>
<p>那静态方法和类方法的区别在哪呢？区别就在类方法的第一个参数是<code>cls</code>，在继承时，<code>cls</code>指的是当前类而不是父类。也就是说，同样的类方法在不同的子类中可以有不同的表现，有点重载的意思。见下面的例子：</p>
<p>我们重写Date函数：</p>
<pre><code class="language-python">class Date:
  def __init__(self, month, day, year):
    self.month = month
    self.day   = day
    self.year  = year

  def display(self):
    return &quot;{0}-{1}-{2}&quot;.format(self.month, self.day, self.year)

  @staticmethod
  def millenium(month, day):
    return Date(month, day, 2000)
</code></pre>
<p>使用：</p>
<pre><code class="language-python">new_year = Date(1, 1, 2013)                # Creates a new Date object
millenium_new_year = Date.millenium(1, 1)  # also creates a Date object. 

# Proof:
new_year.display()            # &quot;1-1-2013&quot;
millenium_new_year.display()  # &quot;1-1-2000&quot;

isinstance(new_year, Date)  # True
isinstance(millenium_new_year, Date)  # True
</code></pre>
<p>这时来了一个Date类的子类DateTime:</p>
<pre><code class="language-python">class DateTime(Date):
  def display(self):
      return &quot;{0}-{1}-{2} - 00:00:00PM&quot;.format(self.month, self.day, self.year)
</code></pre>
<p>使用：</p>
<pre><code class="language-python">datetime1 = DateTime(10, 10, 1990)
datetime2 = DateTime.millenium(10, 10)

isinstance(datetime1, DateTime)  # True
isinstance(datetime2, DateTime)  # False

datetime1.display()  # returns &quot;10-10-1990 - 00:00:00PM&quot;
datetime2.display()  # returns &quot;10-10-2000&quot; 
</code></pre>
<p>显然<code>datetime2</code>是<code>Date</code>的实例而不是<code>DateTime</code>的实例。</p>
<p>很多情况下，我们并不希望是这样的结果，我们希望上面的<code>datetime2</code>按所在子类指定的形式显示。怎么做呢？使用类方法。将Date类的静态方法替换为下面的类方法：</p>
<pre><code class="language-python">@classmethod
def millenium(cls, month, day):
    return cls(month, day, 2000)
</code></pre>
<p>这时候再使用：</p>
<pre><code class="language-python">datetime1 = DateTime(10, 10, 1990)
datetime2 = DateTime.millenium(10, 10)  # 这里cls会指向DateTime

isinstance(datetime1, DateTime)  # True
isinstance(datetime2, DateTime)  # True

datetime1.display()  # &quot;10-10-1990 - 00:00:00PM&quot;
datetime2.display()  # &quot;10-10-2000 - 00:00:00PM&quot;
</code></pre>
<p>总结下：</p>
<ul>
<li>静态方法其实就是一个定义在类中的方法，只是调用时可以不需要先对类进行实例化，直接用类调用即可。无论后面怎么继承，它的实现不变。</li>
<li>类方法也在调用时也不需要先对类进行实例化，但是它的实现，在继承时是跟随当前的子类的(因为它的第一个参数永远是cls)</li>
<li>它们常用于将数据预处理等封装在类内，避免代码扩散到类外不好维护。</li>
</ul>
<h2 id="7-特殊魔法属性和方法">7. 特殊(魔法)属性和方法</h2>
<p>Python中以双下划线<code>__</code>开头和结尾的属性和方法，叫特殊属性(方法)或魔法属性(方法)。怎么读呢，比如<code>__init__</code>，推荐的读法是&quot;dunder init dunder&quot;(as suggested by Mark Jackson)。对魔法方法而言，其实它的意思是不需要<strong>显式调用</strong>，Python底层会自动调用它们。</p>
<h3 id="71-属性">7.1 属性</h3>
<h4 id="711-_doc_">7.1.1 _<em>doc</em>_</h4>
<p>帮助说明，一般在定义类的时候以<code>'''说明'''</code>形式加的注释会以string的形式存在<code>__doc__</code>中</p>
<h4 id="712-_module_">7.1.2 _<em>module</em>_</h4>
<p>对某个<strong>函数</strong>或者<strong>实例对象</strong>，查看它所在的模块的名字。比如新建了一个<code>test.py</code>文件，里面有一个实例<code>a</code>。若在<code>test.py</code>中直接运行<code>print a.__module__</code>，结果是缺省值<code>__main__</code>；如果在另一个文件中导入了<code>test.py</code>中的<code>a</code>，在另一个文件中运行<code>print a.__module__</code>，结果是<code>test</code>，也就是返回了不带后缀的文件名。</p>
<h4 id="713-_name_">7.1.3 _<em>name</em>_</h4>
<p>返回所在模块的名字，一般<strong>单独使用</strong>，如<code>print __name__</code>。</p>
<p>与<code>__module__</code>相同，直接运行py脚本时，<code>__name__</code>被赋予缺省值<code>__main__</code>；一旦被其他文件或模块导入，那么以前的那个脚本的<code>__name__</code>值就变成了那个脚本的文件名（不带py后缀）</p>
<p>最常用的用法是，在某个py脚本如<code>test.py</code>最后添加：</p>
<pre><code class="language-python">if __name__ == '__main__':
    xxx
</code></pre>
<p>这样做的好处是，直接运行<code>test.py</code>，上面的<code>xxx</code>部分会执行。但是在其他地方<code>import test</code>再运行时，<code>xxx</code>就不会执行了（此时<code>test.py</code>中执行到<code>if</code>语句时，<code>__name__ = test</code>，不再是缺省值，当然不会执行<code>xxx</code>了）</p>
<h4 id="714-_class_">7.1.4 _<em>class</em>_</h4>
<p>返回对象的类信息，也就是查看是谁的实例。顶层是<code>type</code></p>
<h4 id="715-_base_">7.1.5 _<em>base</em>_</h4>
<p>返回类的父类，顶层是<code>object</code></p>
<h4 id="716-_dict_">7.1.6 _<em>dict</em>_</h4>
<p>字典，储存对象的属性。这里我们再回头理解2.2中的类属性和实例属性：</p>
<pre><code class="language-python">class A(object):
    Q = 1
    def __init__(self, q):
        self.q = q

a = A(0)
</code></pre>
<p>查看a和A的属性：</p>
<pre><code class="language-python">print a.__dict__  # {'q': 0}
print A.__dict__  # {'__module__': '__main__', 'Q': 1, '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x1028156e0&gt;}
</code></pre>
<p>看，虽然<code>a</code>可以访问<code>Q</code>，但是<code>a</code>的属性字典的key中并没有<code>Q</code>。因此这里的<code>a.Q</code>和<code>A.Q</code>是完全等同的，都指向的是<code>A</code>的<code>Q</code>属性。</p>
<p>这时，我们对a操作：</p>
<pre><code class="language-python">a.Q = 1
print a.__dict__  # {'q': 0, 'Q': 1}
</code></pre>
<p><code>Q</code>属性就添加到了<code>a</code>的属性字典中。本质就是按照<code>a.attr = val</code>的方式给<code>a</code>新添了一个属性。此时<code>a.Q</code>和<code>A.Q</code>就是两个完全不同的东西了，互不影响。</p>
<h4 id="717-_slots_">7.1.7 _<em>slots</em>_</h4>
<p>在Python中，当我们创建了一个类的实例后，我们还可以给该实例绑定任意新的属性或方法：</p>
<pre><code class="language-python">class P(object):
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        
p = P()
p.z = 5
</code></pre>
<p><code>__slots__</code>的作用：限定运行绑定的属性，目的是为了不浪费内存。</p>
<p>改进如下：</p>
<pre><code class="language-python">class P(object):
    __slots__ = ('x', 'y')  # 只允许使用x和y
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        
p = P()
p.z = 5  # AttributeError: 'P' object has no attribute 'z'
</code></pre>
<p>注意：<code>__slots__</code>设置的属性仅对当前类有效，对继承的子类不起效，除非子类也定义了<code>__slots__</code></p>
<h3 id="72-方法">7.2 方法</h3>
<h4 id="721-__new__-和-__init__">7.2.1 <code>__new__ 和 __init__</code></h4>
<p>在Python中，当我们创建一个类的实例时，其实是先调用<code>__new__(cls[, ...])</code>来创建实例，然后由<code>__init__(self[, ...])</code>方法再对该实例(self)进行初始化</p>
<p>有以下几点需要注意：</p>
<ul>
<li><code>__new__</code>在<code>__init__</code>之前被调用</li>
<li><code>__new__</code>是类方法，<code>__init__</code>是实例方法</li>
<li>若重载<code>__new__</code>方法，需要返回类的实例</li>
</ul>
<p>一般情况下，我们不需要重载 <code>__new__</code> 方法。但在某些情况下，我们想<strong>控制实例的创建过程</strong>，这时可以通过重载 <code>__new__</code>方法来实现。</p>
<p>举个例子：</p>
<pre><code class="language-python">class A(object):
    _dict = dict()

    def __new__(cls):
        if 'key' in A._dict:
            print &quot;EXISTS&quot;
            return A._dict['key']
        else:
            print &quot;NEW&quot;
            return object.__new__(cls)

    def __init__(self):
        print &quot;INIT&quot;
        A._dict['key'] = self
</code></pre>
<p>执行情况：</p>
<pre><code class="language-powershell">&gt;&gt;&gt; a1 = A()
NEW
INIT
&gt;&gt;&gt; a2 = A()
EXISTS
INIT
&gt;&gt;&gt; a3 = A()
EXISTS
INIT
</code></pre>
<h4 id="722-__str__-和-__repr__">7.2.2 <code>__str__ 和 __repr__</code></h4>
<ul>
<li><code>__str__</code>: 要<strong>打印</strong>出来的内容，也就是要<code>str()</code>出来的内容</li>
<li><code>__repr__</code>: 要<strong>输出</strong>来的内容（终端输出），很多时候可以让<code>__repr__ = __str__</code></li>
</ul>
<p>举个例子：</p>
<pre><code class="language-python">class Foo(object):
    def __init__(self, name):
        self.name = name

foo = Foo('yang')
print foo  # &lt;__main__.Foo object at 0x108963f10&gt;
</code></pre>
<p>加上<code>__str__</code>函数：</p>
<pre><code class="language-python">class Foo(object):
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return 'name is %s' % self.name

foo = Foo('yang')
print foo  # name is yang
		   # 等价于调用print str(foo)

# 终端中
&gt;&gt;&gt; foo  # &lt;__main__.Foo object at 0x108963f10&gt;
</code></pre>
<p>若要终端中也显示，需加上<code>__repr__</code>函数：</p>
<pre><code class="language-python">class Foo(object):
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return 'name is %s' % self.name

    def __repr__(self):
        return 'name is %s' % self.name

foo = Foo('yang')

# 终端中
&gt;&gt;&gt; foo  # name is yang
</code></pre>
<p>一般我们可以直接改写为<code>__repr__ = __str__</code>，直接让二者功能一致。</p>
<h4 id="723-_getattr_">7.2.3 _<em>getattr</em>_</h4>
<p><code>__getattr__(self, item)</code>：只在当调用<strong>不存在</strong>的属性attr时会调用此方法(类属性和实例属性中都没有):</p>
<pre><code class="language-python">class Foo(object):
    def __init__(self, name):
        self.name = name
        
    def __getattr__(self, item):
        if item == 'age':
            print 'no such attr!'
</code></pre>
<p>但是有一个问题，上面尝试调用实例的<code>age</code>属性会打印出<code>no such attr!</code>，但是调用其他不存在的属性如<code>gender</code>时, 会返回<code>None</code>，因为<code>__getattr__</code>默认返回的就是<code>None</code>。因此，为了让<code>__getattr__</code>只响应几个特定的属性，建议加入异常处理：</p>
<pre><code class="language-python">def __getattr__(self, item):
    if item == 'age':
        print 'no such attr!'
	raise AttributeError('Point object ha no attribute %s' % item)
</code></pre>
<p><strong>注意：</strong><code>__getattr__</code>并不会影响实例的<code>__dict__</code>属性。</p>
<h4 id="724-_setattr_">7.2.4 _<em>setattr</em>_</h4>
<p><code>__setattr__(self, name, value)</code>: 在尝试给属性赋值时调用此函数。name为属性名，value为要赋的值。简单说，给<code>__dict__</code>添加属性和值就是通过这个函数实现的。</p>
<p>看下面的例子：</p>
<pre><code class="language-python">class Point(object):
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __setattr__(self, name, value):
        print 'call func setattr (%s, %s)' % (name, value)
        return object.__setattr__(self, name, value)

p = Point(1, 2)
</code></pre>
<p>输出的结果是：</p>
<pre><code class="language-shell">call func setattr (x, 1)
call func setattr (y, 2)
</code></pre>
<p>整个的数据流转过程为：</p>
<p>先执行到<code>__init__</code>函数第一行，获取了实例的属性名字<code>x</code>和<code>y</code>，并让x=1，y=2。然后分两次转去调用<code>__setattr__</code>：第一次<code>name</code>为<code>x</code>，<code>value</code>为<code>1</code>，然后执行<code>object.__setattr__</code>函数，跳转到<code>__init__</code>中的<code>self.x = x</code>给实例<code>p</code>的<code>__dict__</code>添加属性--值这样的键值对；第二次<code>name</code>为<code>y</code>，<code>value</code>为<code>3</code>，最后执行<code>__init__</code>中的<code>self.y = y</code>。</p>
<p><strong>注意</strong>：上面<code>return object.__setattr__(self, name, value)</code>等价于<code>self.__dict__[name] = value</code>。这里不能用<code>self.name = value</code>，因为这样会调用自己，然后陷入死循环，最后报错：<code>RuntimeError: maximum recursion depth exceeded</code>。</p>
<h4 id="724-_delattr_">7.2.4 _<em>delattr</em>_</h4>
<p><code>__delattr__(self, name)</code>:删除属性的值。<code>del obj.name</code>就是调用的这个方法</p>
<p>在上小节的代码中加入以下几行：</p>
<pre><code class="language-python">def __delattr__(self, name):
    return object.__delattr__(self, name)
</code></pre>
<p>这样执行<code>del p.x</code>就会执行上述代码。</p>
<h4 id="725-_getattribute_">7.2.5 _<em>getattribute</em>_</h4>
<p><code>__getattribute__(self, name)</code>：无论name是否存在，只要name被访问，就一定调用此方法。</p>
<p>如果同时定义了<code>__getattr__</code>，除非<code>__getattribute__</code>抛出异常，否则不会调用<code>__getattr__</code>。</p>
<p>同样，为了避免死循环，<code>__getattribute__</code>中的实现应该用<code>return object.__getattribute__(self, name)</code>而不能用<code>return self.__dict__(name)</code></p>
<h4 id="726-_call_">7.2.6 _<em>call</em>_</h4>
<p>能让实例直接像函数一样调用，形如<code>x(arg1, arg2)</code>的方式，就是在调用<code>x.__call__(arg1, arg2)</code>。</p>
<pre><code class="language-python">class Point(object):
    def __init__(self, x, y):
        self.x, self.y = x, y
    def __call__(self, z):
        return self.x + self.y + z
</code></pre>
<p>使用如下：</p>
<pre><code class="language-powershell">&gt;&gt;&gt; p = Point(3, 4)
&gt;&gt;&gt; callable(p)     # 使用 callable 判断对象是否能被调用
True
&gt;&gt;&gt; p(6)            # 传入参数，对实例进行调用，对应 p.__call__(6)
13  
</code></pre>
<h4 id="727-__iter__和next">7.2.7 <code>__iter__和next</code></h4>
<p>在某些情况下，我们希望实例对象可被用于 <code>for…in</code> 循环，这时我们需要在类中定义 <code>__iter__</code> 和 <code>next</code>（在 Python3 中是<code>__next__</code>）方法，其中，<code>__iter__</code> 返回一个迭代对象，<code>next</code>返回容器的下一个元素，在没有后续元素时抛出 <code>StopIteration</code>异常</p>
<p>以斐波那契数列为例：</p>
<pre><code class="language-python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1

    def __iter__(self):  # 返回迭代器对象本身
        return self

    def next(self):  # 返回容器的下一个元素
        a = self.a
        self.a, self.b = self.b, self.a + self.b
        return a

fib = Fib()
print fib.next()
for i in fib:
    if i &gt; 10:
        break
    print i
# 0 1 1 2 3 5 8
</code></pre>
<h4 id="728-__getitem__-__setitem__-__delitem__">7.2.8 <code>__getitem__、__setitem__、__delitem__</code></h4>
<p>格式：</p>
<pre><code class="language-shell">__getitem__(self,var):可以使用obj[n]方式获取值,例如Fib函数可以取其中一项.如果使用list的切片功能,就要判断var是否slice对象isinstance(var,slice).slice有start, stop, step属性,负数处理要另外处理
__setitem__(self,var,value):可以用来对值进行赋值时的操作.
__delitem__(self,var):删除某个元素的操作.
</code></pre>
<p>总之，涉及到<code>obj[n]</code>的用法就与以上三个方法有关，它们分别是获取值，设置值，删除值</p>
<p>举个简单例子：</p>
<p>希望对上小节的斐波那契数列<code>Fib</code>使用<code>obj[n]</code>和切片的方式取值，进行如下改写：</p>
<pre><code class="language-python">class Fib(object):
    def __getitem__(self, item):
        if isinstance(item, int):
            a, b = 0, 1
            for i in xrange(item):
                a, b = b, a + b
            return a
        if isinstance(item, slice):
            a, b = 0, 1
            start, stop = item.start, item.stop
            L = []
            for i in xrange(stop):
                if i &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L

fib = Fib()
print fib[3]   # 2
print fib[0:4] # [0, 1, 1, 2]
</code></pre>
<p>综合例子：设计一个Point类，它有一个坐标属性。既能用<code>obj[i]</code>赋值和调用，又能用<code>obj.x</code>和<code>obj.y</code>分别赋值和调用两个坐标值</p>
<pre><code class="language-python">class Point(object):
    def __init__(self, x=0, y=0):
        self.data = [x, y]

    def __str__(self):
        return &quot;point(%s, %s)&quot; % (self.data[0], self.data[1])

    __repr__ = __str__

    def __getitem__(self, item):
        return self.data[item]

    def __setitem__(self, idx, value):
        self.data[idx] = value

    def __delitem__(self, idx):
        del self.data[idx]

    @property
    def x(self):
        return self.data[0]

    @x.setter
    def x(self, x):
        self.data[0] = x

    @property
    def y(self):
        return self.data[1]

    @y.setter
    def y(self, y):
        self.data[1] = y


p = Point(2, 3)   # 
print p           # point(2, 3)
print p[0], p[1]  # 2 3
print p.x         # 2
p.x = 4
print p           # point(4, 3)
</code></pre>
<h2 id="8-property">8. @property</h2>
<p><code>@property</code>可将方法变成属性。</p>
<p>比如有一个类P，其实例p，p有一个私有属性<code>_score</code>（不想暴露），若要调用<code>_score</code>或对其赋值，可以定义<code>get_score</code>和<code>set_score</code>方法。</p>
<p>其实还可以使用<code>property</code>将方法变成属性：</p>
<pre><code class="language-python">class P(object):

    def __init__(self, score):
        self._score = score

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, score):
        self._score = score

p = P(1)
print p.score  # 像属性一样调用
p.score = 2    # 像属性一样直接赋值
print p.score
</code></pre>
<p>上面若只有<code>@property</code>，则<code>score</code>是只读属性。加上<code>setter</code>后才能赋值。</p>
<h2 id="9-元类">9. 元类</h2>
<h3 id="91-继承与实例化">9.1 继承与实例化</h3>
<p>在面向对象体系里面，存在两种关系：</p>
<ul>
<li>继承关系：在python里面用<code>__base__</code>可查看，顶层是<code>object</code></li>
<li>实例关系：表现为某个类型的实例化。在python里面用<code>__class__</code>查看，顶层为<code>type</code>。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; object.__base__  # 继承关系上object为顶层
None
&gt;&gt;&gt; object.__class__  # object是type的实例
&lt;type 'type'&gt;

&gt;&gt;&gt; type.__base__  # type继承自obect
&lt;type 'object'&gt;
&gt;&gt;&gt; type.__class__  # type是type的实例
&lt;type 'type'&gt;

# python中type和object就像鸡和蛋的关系

&gt;&gt;&gt; int.__base__  # int继承自object
&lt;type 'object'&gt;
&gt;&gt;&gt; int.__class__  # int是type的实例
&lt;type 'type'&gt;
</code></pre>
<p>再看一个实例化的例子：</p>
<pre><code class="language-python">&gt;&gt;&gt; class A(object):
... 	pass 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.__class__  # a是A的实例
&lt;class '__main__.A'&gt;
&gt;&gt;&gt; a.__base__  # 报错。实例没有继承关系，所以没有__base__属性
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'A' object has no attribute '__base__'
</code></pre>
<h3 id="92-type的用法">9.2 type的用法</h3>
<ul>
<li><code>type(obj)</code>：获取对象的相应类型，与<code>obj.__class__</code>等同</li>
<li><code>type(className, (parents), {attr: value})</code>：创建并返回一个类，三个参数分别对应于类名(字符串)，父类(元组形式)，属性(字典形式)</li>
</ul>
<p>因此以下两个语句等价：</p>
<pre><code class="language-python">class Integer(object):
    name = 'interger'
    def inc(self, num):
        return num + 1
#------------------------
# 父类元组为空，默认继承object
Integer = type('Integer', (), {'name': 'interger',
                                   'increase': lambda self, num: num + 1})
</code></pre>
<p>也就是说，类的定义过程，其实是<strong>type类型实例化的过程</strong></p>
<h3 id="93-元类metaclass">9.3 元类metaclass</h3>
<p>先总结下：</p>
<ul>
<li>
<p>类的类就是元类（强调实例化），默认是type</p>
</li>
<li>
<p>type是所有元类的<strong>父亲</strong></p>
</li>
<li>
<p>在实例化时，也就是创建类型对象时，会按以下顺序查找<code>__metaclass__</code>属性：</p>
</li>
</ul>
<p><code>class.__metaclass__ -&gt; bases.__metaclass__ -&gt; module.__metaclass__ -&gt; type</code></p>
<p>理解以上几点，看下面例子：</p>
<pre><code class="language-python">&gt;&gt;&gt; class M(type):
... 	pass
&gt;&gt;&gt; M.__class__
&lt;type 'type'&gt;
&gt;&gt;&gt; M.__base__  # 继承自type
&lt;type 'type'&gt;
</code></pre>
<p>上面的M就是一个元类。要实例化，可定义一个类：</p>
<pre><code class="language-python">&gt;&gt;&gt; class TM(object):
... 	__metaclass__ = M  # 指定元类
&gt;&gt;&gt; TM.__class__
&lt;class '__main__.M'&gt;
&gt;&gt;&gt; TM.__base__
&lt;type 'object'&gt;
</code></pre>
<p>其实上面的<code>__metaclass__ = M</code>是一个语法糖，它等价于<code>TM = M('TM', (), {})</code></p>
<h3 id="94-元类的作用">9.4 元类的作用</h3>
<p>元类的作用：控制类的创建过程。</p>
<p>例子: 让定义的类的所有方法和属性名称前面都加上<code>my_</code>前缀：</p>
<pre><code class="language-python">class PrefixMetaclass(type):
    def __new__(cls, className, bases, attrs):
        _attrs = dict(('my_' + name, value) for name, value in attrs.items())
        return type.__new__(cls, className, bases, _attrs)
        # return type(className, bases, _attrs)
        # return super(PrefixMetaclass, cls).__new__(cls, className, bases, _attrs)


class Foo(object):
    __metaclass__ = PrefixMetaclass  # 这样Foo就是PrefixMetaclass的实例了
    name = 'foo'

    def bar(self):
        return 'bar'


foo = Foo()
print foo.name    # AttributeError: 'Foo' object has no attribute 'name'
print foo.my_name # foo
print foo.bar()   # AttributeError: 'Foo' object has no attribute 'bar'
print foo.my_bar()# bar
</code></pre>
<p>参数解释：</p>
<ul>
<li>cls：指向当前类PrefixMetaclass</li>
<li>className: 后面要创建的类名字</li>
<li>bases: 要创建的类的父类</li>
<li>attrs: 要创建的类的属性和方法，为一个字典</li>
</ul>
<p>最后三个return语句本质上是相同的。</p>
<h3 id="95-应用">9.5 应用</h3>
<p>例1:创建一个静态类(static class): 不允许创建实例，通常作为工具类(Utility)存在:</p>
<pre><code class="language-python">class StaticMetaclass(type):
    def __new__(cls, name, base, attr):
        ret = type.__new__(cls, name, base, attr)  # 创建类实例

        def ctor(cls, *args, **kwargs):
            raise RuntimeError(&quot;Cannot create a instance of the static class!&quot;)

        ret.__new__ = staticmethod(ctor)  # 无法实例化

        return ret

class Data(object):
    __metaclass__ = StaticMetaclass

Data()  # RuntimeError: Cannot create a instance of the static class!
</code></pre>
<p>例2: 创建一个密封类(sealed class)：禁止被继承</p>
<pre><code class="language-python">class SealedMetaclass(type):
    _types = set()
    
    def __init__(cls, name, base, attr):
        if cls._types &amp; set(base):  # 其实是只能继承自object，创建的类_types非空，再创建子类会报错
            raise SyntaxError(&quot;Cannot inherit form a sealed class!&quot;)
        cls._types.add(cls)

class A(object):
    __metaclass__ = SealedMetaclass

class B(A):
    pass
# SyntaxError: Cannot inherit form a sealed class!
</code></pre>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
       <!--  <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div> -->
        <br>
        <hr>
        <br>
        <div class="sharethis-inline-share-buttons"></div>
        <div style="color: #ccc;font-size:12px;"><i class="fa fa-user"></i> 本文由<a rel="license" href="/"> CaptainChen </a>创作</div>
        <div style="color: #ccc;font-size:12px;"><i class="fa fa-cc"></i> 该文章采用<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"> 知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。转载请注明出处！</div>
      </div>

      <!--  -->
<!-- 
       -->

      <!-- 来必力City版安装代码 -->
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUwMS83MDU1">
      <script type="text/javascript">
         (function(d, s) {
             var j, e = d.getElementsByTagName(s)[0];

             if (typeof LivereTower === 'function') { return; }

             j = d.createElement(s);
             j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
             j.async = true;

             e.parentNode.insertBefore(j, e);
         })(document, 'script');
      </script>
      <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>
      <!-- City版安装代码已完成 -->

      <footer class="py-12 text-center px-3 md:px-0" v-pre>
  CopyRight © 2017 - 2020
	<br>
	本站已稳定运行
	<strong><script type="text/javascript">
	var urodz= new Date("01/16/2017");
	var now = new Date();
	var ile = now.getTime() - urodz.getTime();
	var dni = Math.floor(ile / (1000 * 60 * 60 * 24));
	document.write(+dni)
	</script>
	</strong>天 总访问量 <strong><span id="busuanzi_value_site_uv"></span></strong> 次

</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E6%96%B0%E5%BC%8F%E7%B1%BBobject%E7%B1%BB%E5%92%8C%E6%97%A7%E5%BC%8F%E7%B1%BB">1. 新式类(object类)和旧式类</a>
<ul>
<li><a href="#11-%E5%AE%9A%E4%B9%89">1.1 定义</a></li>
<li><a href="#12-%E5%8C%BA%E5%88%AB">1.2 区别</a></li>
</ul>
</li>
<li><a href="#2-%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B">2. 类和实例</a>
<ul>
<li><a href="#21-self%E7%9A%84%E4%BD%9C%E7%94%A8">2.1 self的作用</a></li>
<li><a href="#22-%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">2.2 类属性和实例属性</a></li>
<li><a href="#23-%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6">2.3 访问限制</a></li>
<li><a href="#24-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF">2.4 获取对象信息</a></li>
</ul>
</li>
<li><a href="#3-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">3. 命名空间</a></li>
<li><a href="#4-%E7%BB%A7%E6%89%BF">4. 继承</a>
<ul>
<li><a href="#41-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">4.1 基本概念</a></li>
<li><a href="#42-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">4.2 多重继承</a></li>
<li><a href="#43-super%E5%87%BD%E6%95%B0">4.3 super函数</a></li>
</ul>
</li>
<li><a href="#5-%E5%A4%9A%E6%80%81">5. 多态</a></li>
<li><a href="#6-%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">6. 类方法和静态方法</a></li>
<li><a href="#7-%E7%89%B9%E6%AE%8A%E9%AD%94%E6%B3%95%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">7. 特殊(魔法)属性和方法</a>
<ul>
<li><a href="#71-%E5%B1%9E%E6%80%A7">7.1 属性</a>
<ul>
<li><a href="#711-_doc_">7.1.1 _<em>doc</em>_</a></li>
<li><a href="#712-_module_">7.1.2 _<em>module</em>_</a></li>
<li><a href="#713-_name_">7.1.3 _<em>name</em>_</a></li>
<li><a href="#714-_class_">7.1.4 _<em>class</em>_</a></li>
<li><a href="#715-_base_">7.1.5 _<em>base</em>_</a></li>
<li><a href="#716-_dict_">7.1.6 _<em>dict</em>_</a></li>
<li><a href="#717-_slots_">7.1.7 _<em>slots</em>_</a></li>
</ul>
</li>
<li><a href="#72-%E6%96%B9%E6%B3%95">7.2 方法</a>
<ul>
<li><a href="#721-__new__-%E5%92%8C-__init__">7.2.1 <code>__new__ 和 __init__</code></a></li>
<li><a href="#722-__str__-%E5%92%8C-__repr__">7.2.2 <code>__str__ 和 __repr__</code></a></li>
<li><a href="#723-_getattr_">7.2.3 _<em>getattr</em>_</a></li>
<li><a href="#724-_setattr_">7.2.4 _<em>setattr</em>_</a></li>
<li><a href="#724-_delattr_">7.2.4 _<em>delattr</em>_</a></li>
<li><a href="#725-_getattribute_">7.2.5 _<em>getattribute</em>_</a></li>
<li><a href="#726-_call_">7.2.6 _<em>call</em>_</a></li>
<li><a href="#727-__iter__%E5%92%8Cnext">7.2.7 <code>__iter__和next</code></a></li>
<li><a href="#728-__getitem__-__setitem__-__delitem__">7.2.8 <code>__getitem__、__setitem__、__delitem__</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-property">8. @property</a></li>
<li><a href="#9-%E5%85%83%E7%B1%BB">9. 元类</a>
<ul>
<li><a href="#91-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96">9.1 继承与实例化</a></li>
<li><a href="#92-type%E7%9A%84%E7%94%A8%E6%B3%95">9.2 type的用法</a></li>
<li><a href="#93-%E5%85%83%E7%B1%BBmetaclass">9.3 元类metaclass</a></li>
<li><a href="#94-%E5%85%83%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8">9.4 元类的作用</a></li>
<li><a href="#95-%E5%BA%94%E7%94%A8">9.5 应用</a></li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://wizyoung.github.io/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://wizyoung.github.io/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
</body>

</html>