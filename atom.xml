<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wizyoung.github.io</id>
    <title>CaptainChen</title>
    <updated>2020-02-14T13:11:39.354Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wizyoung.github.io"/>
    <link rel="self" href="https://wizyoung.github.io/atom.xml"/>
    <subtitle>Stay hungry, stay foolish</subtitle>
    <logo>https://wizyoung.github.io/images/avatar.png</logo>
    <icon>https://wizyoung.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CaptainChen</rights>
    <entry>
        <title type="html"><![CDATA[Bibtex 文献引用小技巧 -- Identification String]]></title>
        <id>https://wizyoung.github.io/post/bibtex-entries-skill/</id>
        <link href="https://wizyoung.github.io/post/bibtex-entries-skill/">
        </link>
        <updated>2018-08-23T06:33:01.000Z</updated>
        <summary type="html"><![CDATA[<p>LaTeX 中引用参考文献时使用 bibtex 非常方便，然而不同的期刊/会议对于 .bib 条目中的 Booktitle 的要求是不一样的，比如引用一篇 CVPR 文献，有些期刊要求 References 里面写成 In <em>CVPR</em>, 2017，有些又要求写成 In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition，标准不一，每次频繁改来改去，让人十分头疼。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LaTeX 中引用参考文献时使用 bibtex 非常方便，然而不同的期刊/会议对于 .bib 条目中的 Booktitle 的要求是不一样的，比如引用一篇 CVPR 文献，有些期刊要求 References 里面写成 In <em>CVPR</em>, 2017，有些又要求写成 In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition，标准不一，每次频繁改来改去，让人十分头疼。</p>
<!-- more -->
<p>今天无意中在网上看到了纽约州立大学石溪分校计算机实验室的 <a href="https://www3.cs.stonybrook.edu/~cvl/content/others/m_cvl_latex_guide.pdf">LaTeX Guidelines</a>，才发现原来可以使用标致串(Identification String)的小技巧来解决这一痛点，即把 Booktitle 后的字段统一替换为自定义的 Identification String 来提高效率，避免重复操作。举个例子，经过这么一番操作后，ref.bib 文件中的引用条目会变成这样:</p>
<pre><code class="language-shell">@inproceedings{Buch:2017SST,
author = {Buch, Shyamal and Escorcia, Victor and Shen, Chuanqi and Ghanem, Bernard and Niebles, Juan Carlos},
title = {SST: Single-Stream Temporal Action Proposals},
booktitle = CVPR,
year = {2017},
pages = {6373--6382},
publisher = {IEEE}
}
</code></pre>
<p>这里的 booktitle 后的 CVPR 就是一个 Identification String，注意没有大括号包围。它实际上是一个占位符，或者说变量，需要额外定义。因此，我们可以新建一个新的 bib 文件(不妨命名为strings.bib)，里面是各种 Identification String 的定义:</p>
<pre><code class="language-shell">@string{CVPR = &quot;Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition&quot;}
</code></pre>
<p>这样在 tex 文件末尾导入 bib 引用的时候，多导入一个 strings.bib 即可:</p>
<pre><code class="language-shell">\bibliography{strings,ref}
</code></pre>
<p>这样，针对不同的期刊/会议的引用格式要求，我们每次只需要修改 strings.bib 文件即可，效率一下得到极大提高。</p>
<p>当然，这样还有一个好处，那就是在使用文献管理软件时，文章来源一律写成期刊/会议简写即可。比如我使用的 Papers 文献管理软件，对于 Conference 那一栏直接写成对应会议的简写就好:</p>
<figure data-type="image" tabindex="1"><img src="https://wizyoung.github.io/post-images/1581680710249.png" alt="" loading="lazy"></figure>
<p>这样日常的查阅，筛选，管理也会更轻松。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TensorFlow 学习笔记 -- Input Pipeline]]></title>
        <id>https://wizyoung.github.io/post/tensorflow_reading_files/</id>
        <link href="https://wizyoung.github.io/post/tensorflow_reading_files/">
        </link>
        <updated>2018-08-21T16:23:43.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记主要总结了如何在 TensorFlow 如何构建高效的 Input Pipeline，目的是协调 CPU 文件预处理和 GPU 模型计算之间的调度，尽最大限度发挥 GPU 算力。其中涉及到 TFRecord 文件的读写，tf.image 模块对图像的处理，以及版本 1.4 前使用的生产者/消费者多线程文件读写流程，和 1.4 后官方主推的 Dataset 处理方式。后者已经开始逐步支持 eager 模式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记主要总结了如何在 TensorFlow 如何构建高效的 Input Pipeline，目的是协调 CPU 文件预处理和 GPU 模型计算之间的调度，尽最大限度发挥 GPU 算力。其中涉及到 TFRecord 文件的读写，tf.image 模块对图像的处理，以及版本 1.4 前使用的生产者/消费者多线程文件读写流程，和 1.4 后官方主推的 Dataset 处理方式。后者已经开始逐步支持 eager 模式。</p>
<!-- more -->
<p>吐槽部分：这一部分学完后感触很深，tf 真的很难，它已经从一个 Python 库上升到了一个十分复杂的编程语言的高度，让人抓狂。大部分 API 文档是根据代码注释生成的，往往晦涩难懂，由于时间和精力原因去深入庞杂的 C++ 底层几乎不可能。由此带来的最大困扰是，you seldom know what is happening under the hood。比如有多少人知道 tf.image 模块的 resize 的插值方法中，align corners 和主流图像库处理的方式都不一样？在学习这部分的过程中，我翻阅了大量博客，Github Issue，Stack Overflow 回答，多次对着源码逐行分析并进行代码测试，最终总结成个人笔记可谓是“满纸荒唐言，一把辛酸泪”。不过，也正是学习这部分的钻研过程中，感慨 tf 真的是为了实际应用做了充分的考虑，正如 caffe 作者贾扬清在<a href="https://www.zhihu.com/question/63342728/answer/208898814">知乎</a>说道: &quot;TF的确难，但是它给你提供了真正可以产品化的可能性。&quot;</p>
<p>先把这部分我个人觉得要注意的一些点(或者说是大坑)列举一下，方便日后查阅:</p>
<ul>
<li>读取 TFRecord 文件过程中，解析 Example Protobuf 文件时，decode_raw 得到的数据(如 image raw data) 要通过 reshape 操作恢复 shape，而 shape 参数也是从 TFRecord 文件中获取时，要加 tf.stack 操作: image = tf.reshape(image, tf.stack([height, width, channels]))</li>
<li>读取图片时，PIL 的 Image.tobytes() 或 Numpy 的 np.array().tobytes() 得到的二进制文件搭配 tf.decode_raw() 使用；tf.gfile.GFile(img_name) 读取的图片文件要用 tf.image.decode_png() 等函数解析</li>
<li>tf.image.decode_image 得到的图像没有静态 shape，因此无法与 tf.image.resize_images 一起使用。应该尽量使用 tf.image.decode_png 函数</li>
<li>tf.image.resize_images 中有个 align_corners 参数，它的机制与主流图像库如 opencv 是不一样的，建议设置为 True。不然后果可参见 <a href="https://hackernoon.com/how-tensorflows-tf-image-resize-stole-60-days-of-my-life-aba5eb093f35">How Tensorflow’s tf.image.resize stole 60 days of my life</a></li>
<li>tf.image.sample_distorted_bounding_box 得到的 bbox 信息配合 tf.slice 裁剪得到的图像的最后一个维度是动态的，建议后面跟一个 set_shape 操作</li>
<li>tf.image.distorted_bounding_box_crop 函数的 min_object_covered 默认取 0.1，很多时候是不合适的</li>
<li>tf.train.match_filenames_once 和 tf.train.string_input_producer 都创建了局部变量，Session 中需要初始化。</li>
<li>tf.train.batch 和 tf.train.batch_join 的多线程不一样，后者才是一个文件分配一个线程</li>
<li>用 tf.train.batch 等操作出队得到的多元 Tensor tuple 一定要一起 run，不然会错位交叉。参见 3.2.5 例子。</li>
<li>Dataset 模块中, shuffle 的 buffer_size 要好好设计，同时 shuffle 和 repeat 的顺序要注意</li>
<li>Dataset.from_tensor_slices 是把传进来的输入以 tf.constant() 的形式存在于 Graph 中，而一个 Graph Protobuf 文件的上限是 2G</li>
</ul>
<p><strong>推荐阅读:</strong> <a href="https://cs230-stanford.github.io/tensorflow-input-data.html">CS230 课件</a> “An overview of tf.data” 部分列举的所有链接。</p>
<hr>
<h2 id="1-tfrecord">1. TFRecord</h2>
<h3 id="11-tfrecord-格式">1.1 TFRecord 格式</h3>
<p>TFRecord 文件的数据是通过 tf.train.Example 这个 protobuf 的格式存储的。其定义在 <a href="https://www.github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/core/example/example.proto">tensorflow/core/example/example.proto</a> 和 <a href="https://github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/core/example/feature.proto">tensorflow/core/example/feature.proto</a> :</p>
<pre><code class="language-protobuf">message Example {
  // type: Features, name: features
  Features features = 1;
};

message Features {
  // Map from feature name to feature.
  // Features is a key-value store, where each key (string) 
  // maps to a Feature message
  map&lt;string, Feature&gt; feature = 1;
};

// Containers for non-sequential data.
message Feature {
  // Each feature can be exactly one kind.
  oneof kind {
    BytesList bytes_list = 1;
    FloatList float_list = 2;
    Int64List int64_list = 3;
  }
};

// Containers to hold repeated fundamental values.
message BytesList {
  repeated bytes value = 1;
}
message FloatList {
  repeated float value = 1 [packed = true];
}
message Int64List {
  repeated int64 value = 1 [packed = true];
}
</code></pre>
<p>tf.train.Example 中包含名为 features 的 Features 的信息，每个 Features 中包含一个从 feature 名称到 feature 属性 (Feature) 的字典映射(key-value对)，其中每个 Feature 的可以从 BytesList (字符串)，FloatList (浮点实数列表), Int64List (整数列表)中取。<br>
一个 tf.train.Example 的例子:</p>
<pre><code class="language-proto">features {
    feature {
        key: &quot;age&quot;
        value { float_list {
        value: 29.0
        }}
    }
    feature {
        key: &quot;movie&quot;
        value { bytes_list {
            value: &quot;The Shawshank Redemption&quot;
            value: &quot;Fight Club&quot;
        }}
    }
    feature {
        key: &quot;movie_ratings&quot;
        value { float_list {
            value: 9.0
            value: 9.7
        }}
    }
}
</code></pre>
<h3 id="12-文件写入-tfrecord">1.2 文件写入 TFRecord</h3>
<p>样例程序:</p>
<pre><code class="language-python">import tensorflow as tf
import os
import cv2

# 输出的 TFRecord 文件带路径的名称
output = './output.tfrecords'
# 创建一个 writer 来写入 TFRecord 文件
writer = tf.python_io.TFRecordWriter(output)

# 辅助函数，生成整数和字符串型的 tf.train.Feature。
def _int64_feature(value):
    return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))

def _bytes_feature(value):
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))

# 读取图片，并保存到 TFRecord 文件中
img_dir = './img'
imgs = os.listdir(img_dir)
imgs.sort()

for index, img in enumerate(imgs):
    img_path = os.path.join(img_dir, img)
    img_data = cv2.imread(img_path)
    resized_img = cv2.resize(img_data, (128, 128, interpolation=cv2.INTER_AREA))
    # 这里必须把 ndarry 转换成字符串形式的原始二进制数据流
    img_raw = resized_img.tostring()

    # 生成 Example Protobuf 文件
    example = tf.train.Example(features=tf.train.Features(feature={
        'shape_': _int64_feature(resized_img.shape[0]),
        'label_': _int64_feature(index),
        'img_raw': _bytes_feature(img_raw)
    }))

    # 将序列化后的example 写入 TFRecord 文件
    writer.write(example.SerializeToString())
  
writer.close()
</code></pre>
<h3 id="13-读取-tfrecord-文件">1.3 读取 TFRecord 文件</h3>
<pre><code class="language-python">import tensorflow as tf

# 注意默认 shuffle = True
# 返回一个队列 Queue 对象
filename_queue = tf.train.string_input_producer(['./output.tfrecords'], shuffle=False)

# 创建一个 reader 读取 TFRecord 文件中的样例
reader = tf.TFRecordReader()
# 一次读取一个样例。也可以使用 read_up_to 函数一次读取多个样例
# Returns the next record (key, value) pair produced by a reader.
_, serialized_example = reader.read(filename_queue)

# 解析单个 features 文件; 解析多个用 parse_example 函数
features = tf.parse_single_example(
    serialized_example,
    features={
        'shape_': tf.FixedLenFeature([], tf.int64),
        'label_': tf.FixedLenFeature([], tf.int64),
        'img_raw': tf.FixedLenFeature([], tf.string)
    })
# 以上 tf.FixedLenFeature 方法解析的结果为一个 tensor。另一种方法是 tf.VarLenFeature, 解析的
# 结果是 SparseTensor

# 将字符串 tensor 解析成数据 tensor，注意此时为一维数据，需要 reshape
image = tf.decode_raw(features['img_raw'], tf.uint8)
image_shape = tf.stack([shape_, shape_, 3])  # 这一行不能少
image = tf.reshape(image, image_shape)
# 默认是 int64 的 tensor, 转成 int32
shape = tf.cast(features['shape_'], tf.int32)
label = tf.cast(features['label_'], tf.int32)

sess = tf.Session()
# 多线程部分参见第3部分
coord = tf.train.Coordinator()
threads = tf.train.start_queue_runners(sess=sess, coord=coord)

for i in range(4):
    print sess.run([image, shape, label])
</code></pre>
<h2 id="2-tfimage-图像处理">2. tf.image 图像处理</h2>
<h3 id="21-图像读取编码">2.1 图像读取，编码</h3>
<p>读取示例:</p>
<pre><code class="language-python">tf.InteractiveSession()

image_raw_data = tf.gfile.FastGFile('./imgs/img1.png', 'rb').read()
# 一定要明确指定3通道，默认自动识别好像有bug，不生效
img_data = tf.image.decode_png(image_raw_data, channels=3)

# (732, 808, 3) uint8
# 格式: [H, W, C]
print img_data.eval().shape, img_data.eval().dtype
</code></pre>
<p>注意:</p>
<p>(1) tf.gfile 模块为 TensorFlow 的文件读写模块，C++ 实现，API 与 Python 自带文件模块高度相近。区别在于，tf.gfile 实现了多种文件系统的读写，比如本地文件，谷歌云存储文件(前缀 gs://)，HDFS 文件(前缀 hdfs://) 等等。TensorFlow 中写入载入 checkpoints，TensorBoard 日志文件等都是用 tf.gfile 模块实现。</p>
<p>简言之，tf.gfile 实现了更多文件读写接口，在处理日常本地文件读写时，tf.gfile 并没有明显的速度优势，用 python 自带文件读写模块就可以了。</p>
<p>(2) tf.gfile.GFile, tf.gfile.FastGFile 二者在<a href="https://github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/python/platform/gfile.py">r1.8源码实现</a>上并无区别，都是没有线程锁的文件 I/O，所以二者等同。</p>
<p>(3) 图像编码时的搭配:</p>
<ul>
<li>使用 PIL 的 Image.tobytes() 或 Numpy 的 np.array().tobytes() 得到的二进制文件，解码时应该使用<code>tf.decode_raw()</code>函数；</li>
<li>使用 tf.gfile.GFile() 读取的图片文件，使用 tf.image 模块下的 tf.image.decode_png() 等解码。</li>
</ul>
<p>如上面的例子，可以改成下面的写法:</p>
<pre><code class="language-python">image = cv2.imread('./imgs/img1.png')
print image.shape  # (732, 808, 3)
image_raw_data = tf.decode_raw(image.tobytes(), tf.uint8)
print image_raw_data.eval().shape  # (1774368,) // 1774368 = 732 * 808 * 3
</code></pre>
<p>注意 tf.decode_raw() 里面第二个形参 out_type 一定要正确，否则输出的数据的维度就不对。</p>
<p>(4) tf.image 中解码图像的 API：</p>
<ul>
<li>tf.image.decode_png, tf.image.decode_jpeg, tf.image.decode_gif</li>
<li>tf.image.decode_image</li>
</ul>
<p>上面的函数 tf.image.decode_png 等返回的 tensor 是有静态 shape的，而下面的 tf.image.decode_image 由于使用了 tf.cond 判断图片类型，因此返回的 tensor 没有静态 shape，造成它解码的图片无法与tf.image.resize_images() 一起使用；</p>
<p>现在 tf.image.decode_png，tf.image.decode_jpeg 已经能读取所有图片文件类型，和非动态 gif 文件了；</p>
<p>务必明确指定 tf.image.decode_png() 等函数中的 channels，想要 RGB 图务必指定为 3，默认的0在 1.8 版本并未生效。</p>
<p>--&gt; 总结: <code>使用 tf.image.decode_png() 函数，不要使用 tf.image.decode_images() 函数，注意 channels 参数手动指定。返回的数据类型为 tf.uint8。</code></p>
<p>(5) 图像的存储 API:</p>
<ul>
<li>tf.image.encode_png</li>
<li>tf.image.encode_jpeg</li>
</ul>
<pre><code class="language-python">encoded_image = tf.image.encode_png(img_data)
with tf.gfile.FastGFile('test.png', 'wb') as f:
    f.write(encoded_image.eval())
</code></pre>
<p>函数第一个参数为图片数据，shape: [height, width, channels]，数据类型必须为 uint8。同时, 两个函数中提供了图片品质压缩参数，encode_png 为 compression，0-9 之间取值，数值越大压缩越严重；encode_jpeg 为 quality，0-100之间取值，数值越大质量越好。</p>
<h3 id="22-图像大小调整">2.2 图像大小调整</h3>
<blockquote>
<p>说明：后续的图像操作，很多只接受浮点图像数据，有些先把图像转成浮点，处理完成后再转为原来的数据类型；如果有多个图像处理操作，来回在 uint8 和 float32 之间的转换会导致精度损失，因此建议在图像处理之前先统一转换成 float32 类型:</p>
<pre><code class="language-python">img_data = tf.image.convert_image_dtype(img_data, tf.float32)
</code></pre>
</blockquote>
<ul>
<li>tf.image.resize_images(images, size, method=ResizedMethod.BILINEAR, align_corners=False)</li>
</ul>
<p>输入：</p>
<pre><code class="language-shell">images: 4D 的 [N, H, W, C] 或 3D 的 [H, W, C] 数据。因此这个函数支持批处理。

size: [new_height, new_width]

method: 默认双线性插值。可选0-3。0：双线性插值；1：最近邻法；2：双三次插值；3：面积插值
	
align_corners: 角度是否对齐。`记得务必设置为 True`
</code></pre>
<blockquote>
<p>说明: tf 中的图片 resize 和 opencv，PIL 等主流库的实现不一样。opencv 等主流库在插值计算时，对齐时是把每个像素看做一个“点区域”，因此用的是中心点对齐，有个 0.5 的偏移计算设置，可参考 <a href="https://blog.csdn.net/deeplan_1994/article/details/78375823">CSDN博客</a>；而 tf 在实现的时候，每个像素就是一个点，align_corners 设置为 False 就是上述博客中没加偏移的情况，显然不合理；align_corners 设置为 True 就是对齐四个角顶点，连续插值。个人觉得 tf 的设置 align_corners=True 更加合理。代码的区别可参加图: https://i.loli.net/2018/08/16/5b755dc364464.png。这一部分的相关讨论参见: https://github.com/tensorflow/tensorflow/issues/6720。</p>
</blockquote>
<p>若要使用 opencv 的 resize 函数，需使用 tf.py_func 包装起来:</p>
<pre><code class="language-python"># img_data is a tensor
img = tf.py_func(lambda input: cv2.resize(input, (4, 4)), [img_data], tf.float32, stateful=False)
print img.eval()
</code></pre>
<h3 id="23-图像裁剪">2.3 图像裁剪</h3>
<ul>
<li>tf.image.resize_image_with_crop_or_pad(image, height, width)</li>
</ul>
<p>输入: image: 4D 的 [N, H, W, C] 或 3D 的 [H, W, C] 数据。因此这个函数支持批处理。</p>
<p>生成一个大小为 [height, width] 的图，图标图像小于原图就裁剪，否则周围填0。注意只是裁剪或填充，没有插值。</p>
<ul>
<li>tf.image.central_crop(image, central_fraction)</li>
</ul>
<p>输入的 image 为 3D tensor。因此不能批处理。central_fraction为 (0, 1] 之间的浮点数。</p>
<p>做中心裁剪，central_fraction 为长和宽裁剪出的比例。比如 [100, 100] 的原图，central_fraction=0.5，那么输出[50, 50] 大小的图。</p>
<ul>
<li>tf.image.crop_to_bounding_box(image, offset_h, offset_w, target_h, target_w)</li>
</ul>
<p>输入:</p>
<pre><code class="language-shell">image: 4D 的 [N, H, W, C] 或 3D 的 [H, W, C] 数据。因此这个函数支持批处理。

offset_h, offset_w: 裁剪区域的左上角坐标

target_h, target_w: 输出区域的大小
</code></pre>
<ul>
<li>tf.image.pad_to_bounding_box(image, offset_h, offset_w, target_h, target_w)</li>
</ul>
<p>输入:</p>
<pre><code class="language-shell">image: 4D 的 [N, H, W, C] 或 3D 的 [H, W, C] 数据。因此这个函数支持批处理。

offset_h, offset_w: 原图上面要补充多少行0，原图左侧要补充多少列0

target_h, target_w: 输出区域的大小。多出的区域一律补0
</code></pre>
<ul>
<li>tf.image.crop_and_resize(): crop 和 resize 一并做了，默认使用双线性插值，角落对齐了。略。</li>
<li>tf.image.decode_and_crop_jpeg(): 裁剪和解码一起做，但是效率更高，因为只解码要裁剪的区域。</li>
</ul>
<h3 id="24-图像翻转">2.4 图像翻转</h3>
<ul>
<li>
<p>tf.image.flip_up_down(image): 垂直翻转</p>
<p>tf.image.random_flip_up_down(image): 随机垂直翻转</p>
</li>
<li>
<p>tf.image.flip_left_right(image): 左右翻转</p>
<p>tf.image.random_flip_left_right(image): 随机左右翻转</p>
</li>
<li>
<p>tf.image.transpose_image(image): 沿对角线翻转。其实就是矩阵转置。</p>
</li>
<li>
<p>tf.image.rot90(image, k=1): 沿逆时针旋转 k 个 90 度。</p>
</li>
</ul>
<p>以上函数均支持单个图像处理和批量处理。</p>
<h3 id="25-图像色彩调整">2.5 图像色彩调整</h3>
<ul>
<li>tf.image.adjust_brightness(image, delta): 调整图像亮度。delta: [-1, 1] 的实数。原理就是先将图像转成 float，然后整个图像加上 delta，再转换回原图的 dtype。因此建议处理之前直接转成 float。支持批处理。</li>
<li>tf.image.adjust_contrast(image, contrast_factor): 调整对比度。contrast_factor: 对比度乘性系数，提高对比度 contrast_factor 倍。原理: (x - mean) * contrast_factor + mean。支持批处理。</li>
<li>tf.image.adjust_hue(image, delta): 调整色相。delta: [-1, 1]</li>
<li>tf.image.adjust_saturation(image, saturation_factor): 调整饱和度。原理: 先将 RGB 图像转换为 HSV 图，然后 S 通道乘以 saturation_factor，最后做有效裁剪后转换回 RGB。</li>
<li>tf.image.adjust_gamma(image, gamma=1, gain=1): 调整图像 gamma 值。</li>
<li>tf.image.per_image_standardization(image): 减均值除方差。</li>
</ul>
<p>说明：</p>
<p>(1) 以上前四个均有 random 函数，如: tf.image.random_brightness, tf.image.random_contrast, 具体参见 API。</p>
<p>(2) 在做一连串的调整操作后，图像的数值分布可能已经越界了。因此在最后一步操作后记得做有效截断:</p>
<pre><code class="language-python">result = tf.clip_by_value(adjusted_image, 0, 1)
</code></pre>
<h3 id="26-处理标注框">2.6 处理标注框</h3>
<ul>
<li>tf.image.draw_bounding_boxes(image, boxes): 在图上画标注框。</li>
</ul>
<p><strong>输入</strong>:</p>
<pre><code class="language-shell">image: 4D 的 [N, H, W, C] 图像。注意数据类型必须为 float。

boxes: [batch, box_num, 4]。bounding box 的坐标，四个点的坐标格式是 [y_min, x_min, y_max, x_max]，这四个参数都是 [0, 1] 的数，表示比例。
</code></pre>
<p>输出: 带框的图像。</p>
<pre><code class="language-python"># img: [h, w, c]
batch_img = tf.expand_dims(img, 0) # [1, 400, 800, 3]
result = tf.image.draw_bounding_boxes(batch_img, boxes=[[[0.1, 0.3, 0.5, 0.7]]])
plt.imshow(result.eval()[0])
plt.show()
</code></pre>
<p>原图上框的位置: 左上角[240, 40]，右下角[560, 200]</p>
<p>注意，框越界并不会报错。</p>
<ul>
<li>tf.image.sample_distorted_bounding_box(image_size, bounding_boxes, min_object_covered=0.1, aspect_ratio_range, max_attempts=None, use_image_if_no_bounding_boxes=None): 根据 Ground_truth 标记框的位置，根据一些约束随机生成图像。用于数据扩充。</li>
</ul>
<p><strong>输入</strong>:</p>
<pre><code class="language-shell">image_size: [h, w, c] 原图的 shape。

bounding_boxes:  [batch, box_num, 4], ground_truth 的位置信息。坐标格式仍然是 [y_min, x_min, y_max, x_max]，四个参数均为 [0, 1] 之间的浮点数，表示比例。

min_object_covered: 默认 0.1。提取的区域至少包含某个 gt 标注框的比例的百分比。

aspect_ratio_range: list, 默认 [0.75, 1.33]。提取区域的宽高比的范围 (ratio = width / height)。

max_attempts: 默认100。最大尝试次数。

use_image_if_no_bounding_boxes: 默认 False。不提供标记框时是否返回原图。
</code></pre>
<p><strong>输出</strong>：元组 (begin, size, bboxes):</p>
<pre><code class="language-shell">begin: [offset_height, offset_width, 0]。输出区域起点，即左上角的坐标。

size: [target_height, target_width, -1]。输出区域的大小。

bboxes: 输出框的坐标，shape: [1, 1, 4]。
</code></pre>
<p>其中输出的 begin 和 size 可作为 tf.slice 的输入，bboxes 可作为 tf.image.draw_bounding_boxes 的输入。</p>
<pre><code class="language-python"># img: [h, w, c]
begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(tf.shape(img),[[[0.1, 0.3, 0.5, 0.7]]], min_object_covered=0.4)
# distorted 为随机提取出来的图像区域
distorted = tf.slice(resized, begin, size)
</code></pre>
<p>**小坑注意：**上面的例子中，由于 tf.slice 收到的 size 中最后一个维度的数是 -1, 意思是多个通道全要提取，具体有几个通道是动态的(要根据输入来定)，因此导致输出的 distorted 最后一个维度也是动态的。</p>
<pre><code class="language-python">print distorted.shape  # (?, ?, ?)
result = tf.image.resize_images(distorted, [200, 200])
print result.shape  # (200, 200, ?)
</code></pre>
<p>由于后面对 distorted 的操作一般不会涉及到图像通道数，为了图像的维度的 shape 能正常获取，最好在 tf.slice 后手动设定一下 shape:</p>
<pre><code class="language-python"># Restore the shape since the dynamic slice based upon the bbox_size loses
# the third dimension.
distorted.set_shape([None, None, 3])
print distorted.shape  # (?, ?, 3)
result = tf.image.resize_images(distorted, [200, 200])
print result.shape  # (200, 200, 3)
</code></pre>
<h3 id="27-颜色空间转换">2.7 颜色空间转换</h3>
<ul>
<li>tf.image.rgb_to_grayscale</li>
<li>tf.image.grayscale_to_rgb</li>
<li>tf.image.hsv_to_rgb</li>
<li>tf.image.rgb_to_hsv</li>
</ul>
<p>注意，以上操作均需要图片的数据类型为 tf.float32</p>
<h3 id="28-inception-图像预处理">2.8 Inception 图像预处理</h3>
<p>这部分的官方代码在 <a href="https://github.com/tensorflow/models/blob/master/research/slim/preprocessing/inception_preprocessing.py">slim/preprocessing/inception_preprocessing.py</a>。</p>
<p>需要注意的两点:</p>
<p>(1) distorted_bounding_box_crop 函数的 min_object_covered 默认取 0.1，根据具体数据集调整这个参数比较合适。</p>
<p>(2) resize 都没有 align_corners.</p>
<pre><code class="language-python">import tensorflow as tf

from tensorflow.python.ops import control_flow_ops

def apply_with_random_selector(x, func, num_cases):
    &quot;&quot;&quot;
    从 func(x, 0), func(x, 1), ..., func(0, num_cases-1) 中随机选一个
    &quot;&quot;&quot;
    sel = tf.random_uniform([], maxval=num_cases, dtype=tf.int32)
    # merge(inputs): 依次判断 inputs 中的元素是否存在, 返回第一个存在的元素的[data, data_index]
    # switch(data, pred): 返回 (output_false, output_true), 如果 pred 为 true, output_true = data, output_false
    # 不存在; 反过来也一样
    return control_flow_ops.merge([
        func(control_flow_ops.switch(x, tf.equal(sel, case))[1], case)
        for case in range(num_cases)])[0]


def distort_color(image, color_ordering=0, fast_mode=True, scope=None):
    &quot;&quot;&quot;
    对图片进行随机色彩变换：调整亮度、饱和度、色相、对比度。
    
    Args:
        image (float): [0, 1] 之间的 3D tensor 图像
        color_ordering (int, optional): Defaults to 0. 可取 0-3，代表不同的随机变换模式。
        fast_mode (bool, optional): Defaults to True. 快速模式下不采用调整色相和对比度的变换。
        scope (optional): Defaults to None.
    
    Returns:
        颜色变换处理后的 float32 图像。
    &quot;&quot;&quot;
    with tf.name_scope(scope, 'distort_color', [image]):
        if fast_mode:
            if color_ordering == 0:
                image = tf.image.random_brightness(image, max_delta=32. / 255.)
                image = tf.image.random_saturation(image, lower=0.5, upper=1.5)
            else:
                image = tf.image.random_saturation(image, lower=0.5, upper=1.5)
                image = tf.image.random_brightness(image, max_delta=32. / 255.)
        else:
            if color_ordering == 0:
                image = tf.image.random_brightness(image, max_delta=32. / 255.)
                image = tf.image.random_saturation(image, lower=0.5, upper=1.5)
                image = tf.image.random_hue(image, max_delta=0.2)
                image = tf.image.random_contrast(image, lower=0.5, upper=1.5)
            elif color_ordering == 1:
                image = tf.image.random_saturation(image, lower=0.5, upper=1.5)
                image = tf.image.random_brightness(image, max_delta=32. / 255.)
                image = tf.image.random_contrast(image, lower=0.5, upper=1.5)
                image = tf.image.random_hue(image, max_delta=0.2)
            elif color_ordering == 2:
                image = tf.image.random_contrast(image, lower=0.5, upper=1.5)
                image = tf.image.random_hue(image, max_delta=0.2)
                image = tf.image.random_brightness(image, max_delta=32. / 255.)
                image = tf.image.random_saturation(image, lower=0.5, upper=1.5)
            elif color_ordering == 3:
                image = tf.image.random_hue(image, max_delta=0.2)
                image = tf.image.random_saturation(image, lower=0.5, upper=1.5)
                image = tf.image.random_contrast(image, lower=0.5, upper=1.5)
                image = tf.image.random_brightness(image, max_delta=32. / 255.)
            else:
                raise ValueError('color_ordering must be in [0, 3]')

        # 有效截断
        return tf.clip_by_value(image, 0.0, 1.0)

# min_object_covered 默认为 0.1，可以根据实际任务稍微改大一点
def distorted_bounding_box_crop(image,
                                bbox,
                                min_object_covered=0.1,
                                aspect_ratio_range=(0.75, 1.33),
                                area_range=(0.05, 1.0),
                                max_attempts=100,
                                scope=None):
    with tf.name_scope(scope, 'distorted_bounding_box_crop', [image, bbox]):
        sample_distorted_bounding_box = tf.image.sample_distorted_bounding_box(
            tf.shape(image),
            bounding_boxes=bbox,
            min_object_covered=min_object_covered,
            aspect_ratio_range=aspect_ratio_range,
            area_range=area_range,
            max_attempts=max_attempts,
            use_image_if_no_bounding_boxes=True)
        bbox_begin, bbox_size, distort_bbox = sample_distorted_bounding_box

        cropped_image = tf.slice(image, bbox_begin, bbox_size)
        return cropped_image, distort_bbox

def preprocess_for_train(image, height, width, bbox,
                         fast_mode=True,
                         scope=None,
                         add_image_summaries=True):
    &quot;&quot;&quot;
    训练集数据预处理。
    
    Args:
        image: 输入图像, uint8 或者 float32(都会被转换为 float32). shape: [H, W, C]
        bbox: shape: [1, num_boxes, coords]. coords: [ymin, xmin, ymax, xmax]. 为 None 时取原图整图.
        fast_mode: resize 插值和颜色变换是否采用快速模式。
        add_image_summaries: 是否画出画出中间处理过程得到的图。
    
    Returns:
        3D float 图像。范围在 [-1, 1] 之间。
    &quot;&quot;&quot;
    with tf.name_scope(scope, 'distort_image', [image, height, width, bbox]):
        # bbox 为空取原图
        if bbox is None:
            bbox = tf.constant([0.0, 0.0, 1.0, 1.0],
                                dtype=tf.float32,
                                shape=[1, 1, 4])
        if image.dtype != tf.float32:
            image = tf.image.convert_image_dtype(image, dtype=tf.float32)
        image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
                                                    bbox)
        if add_image_summaries:
        tf.summary.image('image_with_bounding_boxes', image_with_box)

        distorted_image, distorted_bbox = distorted_bounding_box_crop(image, bbox)
        # Restore the shape since the dynamic slice based upon the bbox_size loses
        # the third dimension.
        distorted_image.set_shape([None, None, 3])
        image_with_distorted_box = tf.image.draw_bounding_boxes(
            tf.expand_dims(image, 0), distorted_bbox)
        if add_image_summaries:
        tf.summary.image('images_with_distorted_bounding_box',
                        image_with_distorted_box)

        # 快速模式下: resize 采取双线性插值，否则是选择随机方法插值。
        num_resize_cases = 1 if fast_mode else 4
        distorted_image = apply_with_random_selector(
            distorted_image,
            lambda x, method: tf.image.resize_images(x, [height, width], method),
            num_cases=num_resize_cases)

        if add_image_summaries:
        tf.summary.image('cropped_resized_image',
                        tf.expand_dims(distorted_image, 0))

        # 随机左右翻转
        distorted_image = tf.image.random_flip_left_right(distorted_image)

        # 调用 distort_color 随机做颜色变换，选择是否采用快速模式。
        num_distort_cases = 1 if fast_mode else 4
        distorted_image = apply_with_random_selector(
            distorted_image,
            lambda x, ordering: distort_color(x, ordering, fast_mode),
            num_cases=num_distort_cases)

        if add_image_summaries:
        tf.summary.image('final_distorted_image',
                        tf.expand_dims(distorted_image, 0))
        # [0, 1] 之间的图，变为 [-1, 1] 之间。
        distorted_image = tf.subtract(distorted_image, 0.5)
        distorted_image = tf.multiply(distorted_image, 2.0)
        return distorted_image


def preprocess_for_eval(image, height, width,
                        central_fraction=0.875, scope=None):
    &quot;&quot;&quot;
    验证集数据预处理。做中心裁剪，双线性插值 resize，数值范围变换到 [-1, 1] 之间。
    
    Returns:
        3D float 图像。范围在 [-1, 1] 之间。
    &quot;&quot;&quot;

    with tf.name_scope(scope, 'eval_image', [image, height, width]):
        if image.dtype != tf.float32:
            image = tf.image.convert_image_dtype(image, dtype=tf.float32)
        # 取出中间 0.875 的区域
        if central_fraction:
            image = tf.image.central_crop(image, central_fraction=central_fraction)

        if height and width:
            # resize 图像，采用双线性插值
            image = tf.expand_dims(image, 0)
            image = tf.image.resize_bilinear(image, [height, width],
                                            align_corners=False)
            image = tf.squeeze(image, [0])
            # 取值范围变为 [-1, 1] 之间
            image = tf.subtract(image, 0.5)
            image = tf.multiply(image, 2.0)
        return image


def preprocess_image(image, height, width,
                     is_training=False,
                     bbox=None,
                     fast_mode=True,
                     add_image_summaries=True):
    &quot;&quot;&quot;
    训练集和验证集图像预处理。
    
    Args:
        image: 输入图像, uint8 或者 float32(都会被转换为 float32). shape: [H, W, C]
        is_training: 训练集还是测试集
        bbox: 标记框，默认 None 表示取原图整图
        fast_mode: resize 和颜色变换是否采用快速模式
        add_image_summaries: 中间处理后的图是否画图。
    
    Returns:
        3D float 图像。范围在 [-1, 1] 之间。
    &quot;&quot;&quot;

    if is_training:
        return preprocess_for_train(image, height, width, bbox, fast_mode,
                                    add_image_summaries=add_image_summaries)
    else:
        return preprocess_for_eval(image, height, width)
</code></pre>
<p>其他的如 VGG 预处理，可参见: <a href="https://github.com/tensorflow/models/blob/master/research/slim/preprocessing/vgg_preprocessing.py">vgg_preprocessing.py</a>，VGG 裁剪图片时是确定短边长度后再等比例 resize.</p>
<h2 id="3-队列与多线程旧-api">3. 队列与多线程（旧 API）</h2>
<h3 id="31-队列-queue">3.1 队列 Queue</h3>
<p>TensorFlow 中提供的队列有:</p>
<ul>
<li>tf.FIFOQuese: 先进先出队列</li>
<li>tf.RandomShuffleQueue: 随机顺序出列的队列。<strong>注意</strong>：测试发现，在满足队列容量 &gt; min_after_dequeue 条件下，每 dequeue 一次，整个 Queue 就要 Shuffle 一次。</li>
<li>tf.PaddingFIFOQueue: 以固定长度批量出列的队列</li>
<li>tf.PriorityQueue: 带优先级出列的队列</li>
</ul>
<p>这些类型的 Queue 的 API 大致差不多，以 FIFOQueue 为例:</p>
<pre><code class="language-shell">tf.FIFOQueue(capacity, dtypes, shapes=None): capacity 为队列容量，dtypes 为队列中元素的数据类型，shapes 为队列中元素的 shape。
-&gt; 常用函数:
- dequeue(): 出队一个元素
- dequeue_many(n): 出队 n 个元素。使用此函数必须手动指定 shapes。
- enqueue(): 入队一个元素
- enqueue_many(val): 入队多个元素. 注意这里 val 要比基元多一维。
- size(): 返回队列中元素多少。返回数据类型为 tensor。
</code></pre>
<p>注意: 队列中存储了 capacity 个基元，以 list 形式存在。当基元中包含多个数据时，dtypes 是个 list，长度与基元长度要相同。若要使用 dequeue_many(n)，shape 必须手动指定。</p>
<pre><code class="language-python">q = tf.FIFOQueue(5, tf.int32, shapes=[()])
op1 = q.enqueue_many([[1, 2]])
op1.run()
op2 = q.enqueue([3])
op2.run()
print q.size().eval()  # 3
print q.dequeue().eval()  # 1
print q.dequeue_many(2).eval()  # [2, 3]
</code></pre>
<blockquote>
<p>TODO(20180817): 当基元有多个元素时，enqueue_many 表现很奇怪，尚未弄懂。因此暂时避免使用 enqueue_many 和 dequeue_many。</p>
</blockquote>
<h3 id="32-tftraincoordinator-与-tftrainqueuerunner">3.2 tf.train.Coordinator 与 tf.train.QueueRunner</h3>
<ul>
<li>tf.train.Coordinator: tf 中用来协调线程运行的工具。主要用于协调线程停止。</li>
<li>tf.train.QueueRunner: tf 中对操作队列多线程的封装，用于创造线程。</li>
</ul>
<h4 id="321-tftraincoordinator">3.2.1 tf.train.Coordinator</h4>
<p>该类的常用方法:</p>
<ul>
<li>should_stop(): 查询线程是否要终止。返回布尔值。</li>
<li>request_stop(): 请求终止线程。每一个线程都可以调用 request_stop() 来请求终止其他线程，这样其他线程在检查 should_stop() 时得到 True，因此就会终止线程。</li>
<li>clear_stop(): 清除线程终止信号。</li>
<li>join(threads=None, stop_grace_period_secs=120): 阻塞线程。发出线程终止请求后，其他线程必须在 stop_grace_period_secs 时间内完成终止，否则抛出异常。</li>
<li>stop_on_exception(): 上下文管理。当发生异常是，请求终止线程。</li>
</ul>
<p>使用方法:</p>
<pre><code class="language-python">try:
    coord = tf.train.Coordinator()
    ... codes of creating threads ...
    coord.join(threads)
except Exception as e:
    ... some codes ...
</code></pre>
<p>上面创建线程的代码为:</p>
<pre><code class="language-python">try:
    while not coord.should_stop():
        ... some work ...
except Exception as e:
    coord.request_stop(e)
coord.join(threads)
</code></pre>
<p>可以用 stop_on_exception () 简化上面创建线程的代码:</p>
<pre><code class="language-python">with coord.stop_on_exception():
    while not coord.should_stop():
        ... some work ...
coord.join(threads)
</code></pre>
<h4 id="322-tftrainqueuerunner">3.2.2 tf.train.QueueRunner</h4>
<p>tf 中的多线程使用的队列启动方案。与 tf.train.Coordinator 一起使用。</p>
<p>比如一个经典的文件输入流程: 第一批线程通过往第一个队列里面不断填充要处理的文件名；第二批线程从前面的队列取出文件名，然后进行读取处理等操作，得到的张量放在第二个队列；第三批线程从第二个队列中取出张量，组成 batch，输入网络进行训练。</p>
<p>初始化方法:</p>
<pre><code class="language-python">__init__(queue=None, enqueue_ops=None)
</code></pre>
<p>其中 queue 为要操作的队列，enqueue_ops 为要对该队列执行的多线程操作。</p>
<p>tf.train.QueueRunner 常与以下两个类一起使用:</p>
<ul>
<li>tf.train.add_queue_runner(qr, collection=tf.GraphKeys.QUEUE_RUNNERS): 将一个 QueueRunner 添加到图的 collection 中。默认放在 tf.GraphKeys.QUEUE_RUNNERS 这个 collection 中。</li>
<li>tf.train.start_queue_runners(sess=None, coord=None, daemon=True, start=True, collection=tf.GraphKeys.QUEUE_RUNNERS ): 启动图的 collection 中的所有 QueueRunner。默认的 collection 为 tf.GraphKeys.QUEUE_RUNNERS。daemon: 是否为守护进程; start: 是否启动线程，不启动就只是创建线程。</li>
</ul>
<p>一个完整的例子:</p>
<pre><code class="language-python"># 创建队列，入队操作
queue = tf.FIFOQueue(100, tf.float32)
enqueue_op = queue.enqueue([tf.random_normal([])])

# 开启 5 个线程
qr = tf.train.QueueRunner(queue, [enqueue_op] * 5)
tf.train.add_queue_runner(qr)

out_tensor = queue.dequeue()

with tf.Session() as sess:
    coord = tf.train.Coordinator()
    enqueue_threads = tf.train.start_queue_runners(sess=sess, coord=coord)

    for i in range(5):
        print sess.run(out_tensor)
    
    # 终止所有线程
    coord.request_stop()
    coord.join(enqueue_threads)
</code></pre>
<p>当然，上面也可以不使用 tf.train.add_queue_runner 和 tf.train.start_queue_runner 来启动线程。直接用 QueueRunner 的 create_threads(sess, coord=None, daemon=False, start=False) 来启动多个线程:</p>
<pre><code class="language-python">queue = tf.FIFOQueue(100, tf.float32)
enqueue_op = queue.enqueue([tf.random_normal([])])

# 开启 5 个线程
qr = tf.train.QueueRunner(queue, [enqueue_op] * 5)

out_tensor = queue.dequeue()

with tf.Session() as sess:
    coord = tf.train.Coordinator()
    # 手动启动 qr 负责的入队线程
    enqueue_threads = qr.create_threads(sess=sess, coord=coord, start=True)

    for i in range(5):
        print sess.run(out_tensor)
    
    coord.request_stop()
    coord.join(enqueue_threads)
</code></pre>
<h4 id="323-输入文件队列">3.2.3 输入文件队列</h4>
<ul>
<li>
<p>tf.train.match_filenames_once(pattern): 根据正则表达式获取符合要求的文件名列表。返回一个<strong>局部</strong>变量，为文件名列表。因此使用这和函数务必<u><strong>初始化局部变量</strong></u>。</p>
</li>
<li>
<p>tf.train.string_input_producer(string_tensor, num_epochs=None, shuffle=True, capacity=32): 根据文件名返回一个文件名队列，供多线程使用。string_tensor: 装有文件名的 tensor，可由 match_filenames_onces 函数返回，也可用 Python glob 生成等；num_epochs: 加载文件列表的最大轮数，默认无限循环；shuffle: 文件名加入队列前是否打乱；capacity: 队列长度。</p>
<p><strong>注意</strong>: 从<a href="https://github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/python/training/input.py#L194">源码</a>中发现，该函数创建了<strong>局部变量</strong>(对 epoch 进行计数)，因此使用时要<strong>初始化局部变量</strong>(其实不初始化也可以，就不使用 epoch 这个变量)。该函数返回一个 FIFOQueue 用于存放文件名，并生成一个 QueueRunner 进行<strong>单线程</strong>入队操作，该 QueueRunner 放在默认的 tf.GraphKeys.QUEUE_RUNNERS 这个 collection 中。</p>
<p>在指定 num_epoches (如测试时指定为 1 ) 时，队列为空后继续出队，抛出 OutOfRange 异常。</p>
</li>
</ul>
<pre><code class="language-python">sess = tf.InteractiveSession()
# 获取所有 png 图片文件列表
files = tf.train.match_filenames_once('some_path/*.png')

filename_queue = tf.train.string_input_producer(files, shuffle=False)
coord = tf.train.Coordinator()
thread = tf.train.start_queue_runners(sess, coord)
tf.local_variables_initializer().run()

print filename_queue.dequeue().eval()  # 获取一个文件名
</code></pre>
<h4 id="324-readers">3.2.4 Readers</h4>
<p>前面 tf.train.string_input_producer 生成了文件名队列，tf 通过各种 Reader 从这个文件名队列中取文件名，进行文件读取解析。常用的 Reader 有:</p>
<ul>
<li>tf.TFRecordReader: 读取 TFRecord 文件</li>
<li>tf.WholeFileReader: 读取一个文件的全部</li>
<li>tf.TextLineReader: 读取文本文件</li>
<li>tf.FixedLengthRecordReader: 读取固定长度的文件</li>
</ul>
<p>它们的 API 大致相同。常用的方法有:</p>
<ul>
<li>read(queue): 输入为一个 Queue，以 (key, value) 的形式输出单个文件。读取后 Queue 出队一个。</li>
<li>read_up_to(queue, num_records): 以 (keys, values) 的形式输出多个文件。</li>
</ul>
<p>用 Reader 实现 2.1 节的图片读取:</p>
<pre><code class="language-python">files = tf.train.match_filenames_once('some_path/*.png')
filename_queue = tf.train.string_input_producer(files, shuffle=False)
key, value = tf.WholeFileReader().read(filename_queue)
image = tf.image.decode_png(value, channels=3)

with tf.Session() as sess:
    sess.run(tf.local_variables_initializer())
    coord = tf.train.Coordinator()
    threads = tf.train.start_queue_runners(sess=sess, coord=coord)
    print sess.run(image)
</code></pre>
<p>单线程，效率较低。</p>
<h4 id="325-组合训练数据-batching">3.2.5 组合训练数据 (batching)</h4>
<p>一个高效的数据 pipeline 应该是一个生产者——消费者模型，即生产者是一个文件名队列，里面存储要处理的文件的名字，这个队列用单线程处理即可；消费者为多线程从生产者队列里面取出文件名，进行文件读取和预处理，然后放置在另一个队列，最终的数据从这个队列中取出。</p>
<p>一个完整的流程如图:</p>
<figure data-type="image" tabindex="1"><img src="https://wizyoung.github.io/post-images/1581680353625.gif#w90#h30" alt="" loading="lazy"></figure>
<p>TensorFlow 中提供的对应的 batch 数据的函数为:</p>
<ul>
<li>tf.train.batch(tensors, batch_size, num_threads=1, capacity=32, enqueue_many=False, dynamic_pad=False, allow_smaller_final_batch=False): 组合输入的 tensors, 形成一个 batch，放置在新建的一个 Queue 中，并同时新建一个 QueueRunner (添加到默认的 QueueRunner collection)。allow_smaller_final_batch 为 True 时，最后的不够一个 batch 的数据也会留下。返回一个 batch 的数据。</li>
<li>tf.train.shuffle_batch(tensors, batch_size, capacity, min_after_dequeue, num_threads=1, seed=None, dynamic_pad=False, allow_smaller_final_batch=False): 产生打乱顺序的 batch，。与 tf.train.batch 的唯一区别是多了 min_after_dequeue 参数，限制了出队操作后队列中最少元素的数量。因为当队列中元素太少时，打乱的意义就不大了。创建的 Queue 类型是 RandomShuffleQueue。</li>
</ul>
<p><strong>注意</strong>: 以上 dynamic_pad 为 False 时，传入的 tensors 必须显式确定，否则抛出异常。</p>
<ul>
<li>tf.train.batch_join(tensors_list, batch_size, capacity=32, allow_smaller_final_batch=False)</li>
<li>tf.train.shuffle_batch_join(tensors_list, batch_size, capacity, min_after_dequeue, allow_smaller_final_batch=False)</li>
</ul>
<p>一般我们的文件不止一个，比如 <a href="https://www.tensorflow.org/performance/performance_guide">TensorFlow Performance Guide</a> 建议，把大数据文件分割成多个约为 100 MB 的 TFRecord 文件，I/O 性能比较好。这种情况下，多文件，多线程进行读取和预处理操作应该用上面两个函数。</p>
<p>其中，输入的 tensors_list 为 a list of tuples of tensors，创建 len(tensors_list) 个线程，每个线程读取一个文件，然后压入队列:</p>
<pre><code class="language-python"># features 为解析的 TFRecord 文件
image, label = features['image'], features['label']

# 1. 使用 tf.train.batch:
# 返回的 iamge 是个 [N, H, W, C] 的 tensor
# 记住 image 和 label 要一起 run，不然就错位交叉了
image, label = tf.train.batch([image, label], batch_size=10, num_threads=1, capacity=100)

# 2. 使用 tf.train.batch_join:
image, label = tf.train.batch_join([[image, label] for _ in range(4)], batch_size=10, capacity=100)
</code></pre>
<p><strong>比较:</strong> tf.train.batch 是<u>多线程读取一个文件</u>，tf.train.batch_join 是<u>多线程读取多个文件</u>，每个线程负责一个文件。如果同一个文件中样本相似，用 tf.train.batch 显然不合适；使用 tf.train.batch_join() 时，如果线程数大于文件数，那么也存在多个线程读取同一个文件的情况，而且多线程读多个文件的硬盘寻址也是有时间开销的，可能会让效率变低。</p>
<h4 id="326-inception-数据输入框架-旧-api">3.2.6 Inception 数据输入框架 (旧 API)</h4>
<pre><code class="language-python"># coding: utf-8

import tensorflow as tf

files = tf.train.match_filenames_ones('some_path/data.tfrecords-*')
# 训练集，文件名打乱
filename_queue = tf.train.string_input_producer(files, shuffle=True, )

_, serialized_example = tf.TFRecordReader().read(filename_queue)
features = tf.parse_single_example(serialized_example, features={
    'image': tf.FixedLenFeature([], tf.string),
    'label': tf.FixedLenFeature([], tf.int64),
    'height': tf.FixedLenFeature([], tf.int64),
    'width': tf.FixedLenFeature([], tf.int64),
    'channels': tf.FixedLenFeature([], tf.int64)
})

image, label, height, width, channels = features['image'], features['label'], features['height'], features['width'], features['channels']

decoded_image = tf.decode_raw(image, tf.uint8)
decoded_image = tf.reshape(decoded_image, tf.stack([height, width, channels]))

image_size = 299

# 前面的 inception 预处理代码
distorted_image = preprocessing_for_train(decoded_image, image_size, image_size, None)

# 这一部分可以具体调整
num_threads = 10
batch_size = 50
min_after_dequeue = 1000
# as suggested by https://www.tensorflow.org/api_guides/python/reading_data#Batching
capacity = min_after_dequeue + (num_threads + 10) * batch_size

image_batch, label_batch = tf.train.shuffle_batch([distorted_image, label], batch_size=batch_size,
    capacity=capacity, min_after_dequeue=min_after_dequeue, num_threads=num_threads)
# tf.train.shuffle_batch_join 的方案
# image_batch, label_batch = tf.train.shuffle_batch([[distorted_image, label] for i in range(num_threads)], batch_size=batch_size,
#     capacity=capacity, min_after_dequeue=min_after_dequeue)

logit = inference(image_batch)
loss = calc_loss(logit, label_batch)
train_step = ...

with tf.Session() as sess:
    sess.run(tf.global_variables_initializer(), tf.local_variables_initializer())
    coord = tf.train.Coordinator()
    threads = tf.train.start_queue_runners(sess=sess, coord=coord)
	
    with coord.stop_on_exception():
        while not coord.should_stop():
            for i in range(training_epoches):
                sess.run(train_step)
 
    coord.join(threads)
</code></pre>
<h2 id="4-tfdata-模块-新-api">4. tf.data 模块 (新 API)</h2>
<p>tf 1.4 后的数据输入框架，抛弃队列处理的旧 API，使用 Dataset 数据集提供数据的输入。这一部分比较简单，官方文档很详细。</p>
<h3 id="41-api-概览">4.1 API 概览</h3>
<p>(1) 利用数据集的基本步骤:</p>
<ul>
<li>根据数据类型创建对应的 Dataset</li>
<li>定义迭代器 Iterator，并进行相应的初始化</li>
<li>预处理、shuffle、batch</li>
<li>使用 get_next() 从迭代器中取出数据张量</li>
</ul>
<p>(2) 常用的 Dataset:</p>
<ul>
<li>tf.data.Dataset(): 所有 Dataset 的基类</li>
<li>tf.data.TextLineDataset(filenames, compression_type=None, buffer_size=None): 从一个或多个文本文件中读取内容</li>
<li>tf.data.TFRecordDataset(filenames,  compression_type=None, buffer_size=None, num_parallel_reads=None): 从一个或多个 TFRecord 文件中读取内容</li>
<li>tf.data.FixedLengthRecordDataset(filenames, record_bytes, header_bytes=None, footer_bytes=None, buffer_size=None): 从一个或多个二进制文件中读取固定长度内容。</li>
</ul>
<p>(3) Dataset 常用的属性:</p>
<ul>
<li>output_shapes: Dataset 中每个元素的 shape</li>
<li>output_types: Dataset 中每个元素的 type</li>
</ul>
<p>(4) Dataset 常用的方法:</p>
<ul>
<li>
<p>batch(batch_size): 按 batch_size 取一个 batch。最后不够一个 batch_size 也会被取出来，如果不要最后的零头，使用 tf.contrib.data.batch_and_drop_remainder 方法。</p>
</li>
<li>
<p>padded_batch(batch_size, padded_shapes, padding_values=None): 生成 padded batch。</p>
</li>
<li>
<p>shuffle(buffer_size, seed=None, reshuffle_each_iteration=None): 打乱数据集。buffer_size: 缓冲区大小。默认 reshuffle_each_iteration 为 True。因此，每迭代一个元素出来，缓冲区中填充一个新元素，shuffle 一次。buffer_size 越大，打乱性能越好，但是第一次启动的时间就较长。可设置 buffer_size 为数据集大小，这样打乱充分。参考<a href="https://stackoverflow.com/questions/46444018/meaning-of-buffer-size-in-dataset-map-dataset-prefetch-and-dataset-shuffle/48096625#48096625">链接</a>。</p>
</li>
<li>
<p>repeat(count=None): 把 Dataset 重复 count 次。None 或 -1 表示无限循环。</p>
</li>
<li>
<p>skip(count): 跳过前 count 个元素。</p>
</li>
<li>
<p>take(count): 读取前 count 个元素。</p>
</li>
<li>
<p>shard(num_shards, index): 生成一个只包含原 Dataset 的 1/num_shards 的新 Dataset。</p>
</li>
<li>
<p>from_tensors(tensors): 根据单个元素构建 Dataset。</p>
</li>
<li>
<p>from_tensor_slices(tensors): 根据元素切片构建 Dataset。</p>
</li>
<li>
<p>from_generator(generator, output_types, out_shapes=None): 根据生成器构建 Dataset。这一部分使用 tf.py_func 实现的。</p>
</li>
<li>
<p>map(map_func, num_parallel_calls=None): map 运算，返回一个 map 运算后的 Dataset。</p>
</li>
<li>
<p>flat_map(map_func): map_func 后再 flat 展平，返回一个 Dataset。</p>
</li>
<li>
<p>filter(predicate): filter 运算，返回一个 Dataset。</p>
</li>
<li>
<p>interleave(map_func, cycle_length, block_length=1): 适用于分布式文件系统。当有多个文件时，一次对 cycle_length 个文件同时读取，block_length 是<strong>每个</strong>线程输出元素的个数。因此，map 和 flat_map 相当于 tf.train.batch，interleave 相当于 tf.train.batch_join。</p>
</li>
<li>
<p>apply(transformation_func): 对一个 Dataset 进行某个操作，类似于 map。</p>
</li>
<li>
<p>zip(datasets): 和 Python 中的 zip 函数一样，把多个 Dataset zip起来。</p>
</li>
<li>
<p>concatenate(dataset): 串接一个 Dataset, 返回一个新的合并的 Dataset。</p>
</li>
<li>
<p>prefetch(buffer_size): 预加载 buffer_size 的数据。</p>
</li>
<li>
<p>range(*args): 生成一个 RangeDataset。</p>
</li>
<li>
<p>list_files(file_pattern, shuffle=None): 根据文件名 file_pattern 正则表达式，获取一个包含这些文件的 Dataset。注意，这个顺序是不定的，即使 shuffle 为 False。看源码发现这个函数其实是先用 tf.matching_files 得到文件列表，在用 from_tensor_slices 得到一个 dataset，最后 shuffle。注意，最后一个 shuffle 默认的缓冲区为整个文件名列表。因此，由于 from_tensor_slices 和 shuffle 缓冲区长度的设定，当文件名列表过于巨大时，这一步耗时就会很大，可参考 <a href="https://github.com/tensorflow/tensorflow/issues/17810">Github</a>。</p>
</li>
</ul>
<p>（5）迭代器:</p>
<ul>
<li><strong>one-shot iterator</strong>: Dataset.make_one_shot_iterator()。绑定一个 Dataset 的单次迭代器，只对 Dataset 进行一次迭代。<strong>只有这个不需要显式初始化</strong>。所有参数都已经确定，中间不能修改了。</li>
<li><strong>initializable iterator</strong>: Dataset.make_initializable_iterator(): 绑定一个 Dataset 的可初始化迭代器。需要手动初始化迭代器。中间可以修改迭代器参数，可以配合 placeholder 使用。</li>
<li><strong>reintializable iterator</strong>: tf.data.Iterator.from_structure(output_types, output_shapes=None, shard_names=None, output_classes=None): 这个迭代器没有绑定 Dataset，因此是用 Iterator 这个类创建的。中间可以重复初始化。把<u>同一个迭代器应用到不同的数据集从而实现切换数据集的功能</u>。需要手动初始化，需要使用 iterator.make_initializer(dataset) 来针对给定的 Dataset 初始化。</li>
<li><strong>feedable iterator</strong>: tf.data.Iterator.from_string_handle(string_handle, output_types, output_shaps=None, output_classes=None): 这个迭代器没有绑定 Dataset。目的是<u>切换到不同的 iterator</u> 。string_handle 是代表一个 Iterator 的 Tensor，可先用一个 placeholder 占据，选择数据集的时候 feed 为具体 Dataset 的 Iterator (用这个 Dataset 的 Iterator.string_handle() 得到)。</li>
</ul>
<h3 id="42-案例分析">4.2 案例分析</h3>
<h4 id="421-性能优化">4.2.1 性能优化</h4>
<p>以一个简单的文本处理为例，假设为分布式文件系统，有 5 个 txt 文件，每个文件里面存放某一类样本的文件名和类别标号，形如:</p>
<pre><code class="language-shell">- file1.txt:
	cat1.jpg 0
 	cat2.jpg 0
 	...
 	cat4.jpg 0
- file2.txt
	dog1.jpg 1
	dog2.jpg 1
	...
	dog4.jpg 1
...
- file_n.txt
</code></pre>
<p>(1) 基本流程，无各种优化考虑:</p>
<pre><code class="language-python"># 获取文件列表，并按照 file_{n} 中的数字 n 从小到大排序
txt_files = glob.glob('some_path/*.txt')
txt_files.sort(key=lambda x: int(x.split('.')[-2][-1]))

# 使用 TextLineDataset 读取文本文件
dataset = tf.data.TextLineDataset(txt_files)
dataset = dataset.shuffle(buffer_size=20)
dataset = dataset.repeat(2)
# 分割字符串，按空格分割
dataset = dataset.map(lambda x: tf.string_split([x], delimiter=' ').values)
dataset = dataset.batch(2)

# 创建迭代器
iterator = dataset.make_one_shot_iterator()
next_element = iterator.get_next()
</code></pre>
<p>输出的结果为:</p>
<pre><code class="language-shell">[['bird1.jpg' '3']
 ['dog4.jpg' '1']]
[['dog2.jpg' '1']
 ['bird3.jpg' '3']]
 ...
</code></pre>
<p>要注意的几点:</p>
<p>-- 参考 4.1 中设置 shuffle 的 buffer_size</p>
<p>-- shuffle 和 repeat 的顺序，建议先 shuffle 再 repeat，如果反过来会造成打乱效果变差。参考: <a href="https://www.tensorflow.org/performance/datasets_performance#repeat_and_shuffle">Dataset Performance Guide</a>。</p>
<p>(2) 基础性能优化: 多线程读取多文件，多线程 map，预加载 prefetch</p>
<p>上面代码的性能缺点：单线程读取，单线程 map，加上 Dataset 默认的 lazy 属性，性能地下。</p>
<p>基础改进代码:</p>
<pre><code class="language-python">txt_files = glob.glob('some_path/*.txt')
txt_files.sort(key=lambda x: int(x.split('.')[-2][-1]))

# 改进1：多线程读取文件，创建5个线程，每个线程负责一个文件读取。
# 因此改进后可以同时读 5 个文件
dataset = tf.data.Dataset.from_tensor_slices(txt_files)
dataset = dataset.interleave(lambda x: tf.data.TextLineDataset(x),
    cycle_length=5, block_length=1)

dataset = dataset.shuffle(buffer_size=20)
dataset = dataset.repeat(2)
# 改进2: 多线程 map 函数，也就是可以多线程预处理了。
dataset = dataset.map(lambda x: tf.string_split([x], delimiter=' ').values，
    num_parallel_calls=4)
dataset = dataset.batch(2)

# 改进3：预加载，输出有缓冲区。类似于消费者队列中填充一定 batch 数，等待消费。
# 这里是基于前一步操作后的元素，因此是预加载 5 个 batch。
dataset = dataset.prefetch(5)
...
</code></pre>
<p><strong>TODO:</strong> 上面的 interleave 同时读取 5 个文件，但是真的是并行吗？按照 <a href="https://docs.google.com/presentation/d/16kHNtQslt-yuJ3w8GIx-eEH6t_AvFeQOchqGRFpAD7U/edit#slide=id.g254d08e080_0_370">tf.data API slides</a> 应该是并行 I/O，但是按照 <a href="https://www.tensorflow.org/performance/datasets_performance">Dataset Performance Guide</a> 却建议使用 tf.contrib.data.parallel_interleave() 实现真正的并行 I/O，这里有待进一步明确，是否需要改成下面的版本:</p>
<pre><code class="language-python">dataset = dataset.apply(tf.contrib.data.parallel_interleave(tf.data.TextLineDataset, cycle_length=4))
</code></pre>
<p>(3) 进一步优化:</p>
<p>并行化 batch: 当 batch_size 比较大时，取 batch 也是耗时的，因此可以把 map 和 batch 放在一起做多线程，最终改成这样的版本(使用 tf.contrib.data.map_and_batch 函数):</p>
<pre><code class="language-python">txt_files = glob.glob('some_path/*.txt')
txt_files.sort(key=lambda x: int(x.split('.')[-2][-1]))

# 确保运行在 CPU 上
with tf.device('/cpu:0'):
    dataset = tf.data.Dataset.from_tensor_slices(txt_files)
    dataset = dataset.apply(tf.contrib.data.parallel_interleave(tf.data.TextLineDataset, cycle_length=4))

    dataset = dataset.shuffle(buffer_size=20)
    dataset = dataset.repeat(2)
    # 改动这里
    dataset = dataset.apply(tf.contrib.data.map_and_batch(lambda x: tf.string_split([x], delimiter=' ').values, batch_size=2, num_parallel_batches=4))
    dataset = dataset.batch(2)

    dataset = dataset.prefetch(5)
</code></pre>
<p>其他的优化还有内存 cache 等的考虑等，参考 <a href="https://www.tensorflow.org/performance/datasets_performance">Dataset Performance Guide</a> 。</p>
<p>注意：一般而言, batch 耗时相对较少，当电脑核心不太够的时候，并行化的 batch 占据线程也不一定是好事，可能速度也会变慢。</p>
<h4 id="422-各种迭代器的使用及比较">4.2.2 各种迭代器的使用及比较</h4>
<p>(1) initializable iterator: 动态指定 iterator 参数。配合 placeholder 使用。</p>
<pre><code class="language-python"># 指定文件名的 placeholder
txt_files = tf.placeholder(tf.string, [])

dataset = tf.data.TextLineDataset([txt_files])
dataset = dataset.map(lambda x: tf.string_split([x], delimiter=' ').values)

iterator = dataset.make_initializable_iterator()
next_element = iterator.get_next()

iterator.initializer.run(feed_dict={txt_files: './txt_files/file1.txt'})
for i in range(5):
    print next_element.eval()

# 切换到另一个 txt 文件
iterator.initializer.run(feed_dict={txt_files: './txt_files/file2.txt'})
for i in range(2):
    print next_element.eval()

# 中间重新初始化，迭代器从头开始
iterator.initializer.run(feed_dict={txt_files: './txt_files/file2.txt'})
for i in range(5):
    print next_element.eval()
    
</code></pre>
<p>(2) reinitializable iterator: 一个可重复初始化的迭代器，绑定到不同的数据集上去。</p>
<pre><code class="language-python"># 两个数据集
cat_dataset = tf.data.TextLineDataset(['./txt_files/file1.txt']).map(lambda x: tf.string_split([x], delimiter=' ').values)
dog_dataset = tf.data.TextLineDataset(['./txt_files/file2.txt']).map(lambda x: tf.string_split([x], delimiter=' ').values)

# 同一个 reinitializable iterator
iterator = tf.data.Iterator.from_structure(cat_dataset.output_types, dog_dataset._output_shapes)
next_element = iterator.get_next()

# 迭代器初始化
cat_init_op = iterator.make_initializer(cat_dataset)
dog_init_op = iterator.make_initializer(dog_dataset)

# 迭代器绑定到 cat dataset
cat_init_op.run()
for _ in range(5):
    print next_element.eval()

# 迭代器绑定到 dog dataset
dog_init_op.run()
for _ in range(5):
    print next_element.eval()
</code></pre>
<p>通常可以用同一个迭代器绑定到 training set 和 test_set，不过，用前面的 initializer_iterator 也可实现相同功能。</p>
<p>(3) feedable iterator: 迭代器是可变的，目的是通过选择不同数据集的 Dataset 的迭代器来迭代不同的数据。</p>
<pre><code class="language-python"># 创建两个 Dataset
cat_dataset = tf.data.TextLineDataset(['./txt_files/file1.txt']).map(lambda x: tf.string_split([x], delimiter=' ').values)
dog_dataset = tf.data.TextLineDataset(['./txt_files/file2.txt']).map(lambda x: tf.string_split([x], delimiter=' ').values)

# 创建两个 Dataset 对应的迭代器
cat_iterator = cat_dataset.make_one_shot_iterator()
dog_iterator = dog_dataset.make_initializable_iterator()

# 创建代表两个 Dataset 的迭代器的 handle tensor
cat_handle = cat_iterator.string_handle().eval()
dog_handle = dog_iterator.string_handle().eval()

# 根据传入的 handle 选择具体的迭代器
handle = tf.placeholder(tf.string, [])
iterator = tf.data.Iterator.from_string_handle(handle, cat_dataset.output_types, cat_dataset.output_shapes)
next_element = iterator.get_next()

while True:
    # 这里切换数据集，之后再切回 cat_dataset 是继续之前的数据迭代。
    for _ in range(2):
        print next_element.eval(feed_dict={handle: cat_handle})

    dog_iterator.initializer.run()
    for _ in range(2):
        print next_element.eval(feed_dict={handle: dog_handle})
</code></pre>
<p><strong>reinitializable iterator 和 feedable iterator 的区别：</strong></p>
<p>二者都是实现切换数据集的功能，但是 reinitializable iterator 是<strong>同一个迭代器</strong>绑定到不同数据集，切换数据集的时候要重新绑定，然后<strong>初始化</strong>这个迭代器，特点是<strong>切换数据集后从头开始迭代切换到的新数据集</strong>；</p>
<p>feedable iterator 是<strong>针对每个数据集先建立对应的迭代器</strong>，然后选择用哪一个迭代器来选择对应的数据集，如果这些<strong>迭代器在创建的时候先初始化好</strong>，那么在迭代器之间来回切换的时候，**各自的数据集是接着前一次的时间点继续输出的。**比如训练集特别大，并不想训练集完全迭代一轮再验证，迭代一定数量的较少样本后就想测试一次验证集，就可以用这种迭代器。</p>
<h4 id="423-一些应用">4.2.3 一些应用</h4>
<p>(1) 读取 npy 文件:</p>
<p>可以直接用 from_tensor_slices 一次载入：</p>
<pre><code class="language-python">data = np.load('data.npy')
features = data[&quot;features&quot;]
labels = data[&quot;labels&quot;]

dataset = tf.data.Dataset.from_tensor_slices((features, labels))
...
</code></pre>
<p>缺点是：整个 npy 解析出来的数组以 tf.constant() 的形式存在于 Graph 中，而一个 Graph protobuf 文件的上限大小为 2G。</p>
<p>可以使用 initializable_iterator 配合 placeholder 载入:</p>
<pre><code class="language-python">data = np.load('data.npy')
features = data[&quot;features&quot;]
labels = data[&quot;labels&quot;]

# 创建对应的 placeholder
features_placeholder = tf.placeholder(features.dtype, features.shape)
labels_placeholder = tf.placeholder(labels.dtype, labels.shape)

dataset = tf.data.Dataset.from_tensor_slices((features_placeholder, labels_placeholder))
... 一些其他预处理操作等 ...

iterator = dataset.make_initializable_iterator()

sess.run(iterator.initializer, feed_dict={feature_placeholder: features, labels_placeholder: labels})
</code></pre>
<p>上面方案其实也不好。上面两个是官方提供的方案。</p>
<p>Stack Overflow 上提供了其他方案:</p>
<p>比如<a href="https://stackoverflow.com/a/50932872/6631854">这个方案</a>计算出 npy 的 header_bytes 长度，然后用 tf.data.FixedLengthRecordDataset 来解析 npy 二进制文件。如果要并行处理，那么多个 npy 的 header_bytes 长度要一样。</p>
<p>另外，可以用 tf.py_func 来调用 np.load() 函数，然后放到 Dataset.map() 函数里面解决:</p>
<pre><code class="language-python">file_list = ['a.npy', 'b.npy', ...]

def read_npy_file(file):
    return np.load(file).as_type(np.float32)

dataset = tf.data.Dataset.from_tensor_slices(file_list)
dataset = dataset.map(lambda file: tuple(tf.py_func(
	read_npy_file, [file], [tf.float32])))
...
</code></pre>
<p>其他的一些应用可以参考 <a href="https://www.tensorflow.org/guide/datasets">Tensorflow Dataset Guide -- Importing Data</a>，里面有从 Python 迭代器得到 Dataset，读取 csv 等文件，进行 padding 操作，利用 tf.py_func 调用 opencv 等。</p>
<h4 id="424-inception-数据输入框架-新-api">4.2.4 Inception 数据输入框架 (新 API)</h4>
<p>用 tf.data 重写 3.2.6 部分:</p>
<pre><code class="language-python">import tensorflow as tf

IMAGE_SIZE = 299  # 输入图片大小
BATCH_SIZE = 50
SHUFFLE_BUFFER = 10000
NUM_EPOCHES = 100

# 列举 tfrecord 文件名
training_files = tf.train.match_filenames_ones('training_path/data.tfrecords-*')
val_files = tf.train.match_filenames_ones('val_path/data.tfrecords-*')

def tfrecord_parser(record):
    features = tf.parse_single_example(
        record, features={
            'image': tf.FixedLenFeature([], tf.string),
            'label': tf.FixedLenFeature([], tf.int64),
            'height': tf.FixedLenFeature([], tf.int64),
            'width': tf.FixedLenFeature([], tf.int64),
            'channels': tf.FixedLenFeature([], tf.int64)
        }
    )
    label, height, width, channels = features['label'], features['height'], features['width'], features['channels']
    decoded_image = tf.decode_raw(features['image'], tf.uint8)
    decoded_image = tf.reshape(decoded_image, tf.stack([height, width, channels]))
    return decoded_image, label

# 定义 traing dataset 和对应的迭代器
# dataset = tf.data.TFRecordDataset(training_files) 这个效率低
training_dataset = tf.data.Dataset.from_tensor_slices(training_files)
training_dataset = training_dataset.interleave(lambda x: tf.data.TFRecordDataset(x), cycle_length=4)
training_dataset = training_dataset.shuffle(SHUFFLE_BUFFER)
training_dataset = training_dataset.repeat(NUM_EPOCHES)
training_dataset = training_dataset.map(tfrecord_parser, num_parallel_calls=2)
training_dataset = training_dataset.map(lambda image, label: (preprocess_for_train(image, IMAGE_SIZE, IMAGE_SIZE), label), num_parallel_calls=4)
training_dataset = training_dataset.batch(BATCH_SIZE)
training_dataset = training_dataset.prefetch(5)

training_iterator = training_datasetmake_initializable_iterator()
training_image_batch, training_label_batch = training_iterator.get_next()

# 网络训练部分
logit = inference(training_image_batch)
loss = calc_loss(logit, training_label_batch)
train_step = ...

# 创建 validation dataset 和对应的迭代器
val_dataset = tf.data.TFRecordDataset(val_files)
val_dataset = val_dataset.map(tfrecord_parser)
val_dataset = val_dataset.map(lambda image, label: (preprocess_for_val(image, IMAGE_SIZE, IMAGE_SIZE), label), num_parallel_calls=2)
val_dataset = val_dataset.batch(BATCH_SIZE)

val_iterator = val_dataset.make_initializable_iterator()
val_image_batch, val_label_batch = val_iterator.get_next()

# 网络测试部分
val_logit = inference(val_image_batch)
predictions = tf.argmax(val_logit, axis=-1, output_type=tf.int32)

with tf.Session() as sess:
    sess.run(tf.global_variables_initializer(), tf.local_variables_initializer())

    sess.run(training_iterator.initializer)
    while True:
        try:
            sess.run(train_step)
        except tf.errors.OutOfRangeError:
            break
    
    sess.run(val_iterator.initializer)
    val_results = []
    val_labels = []
    while True:
        try:
            pred, label = sess.run([predictions, val_label_batch])
            val_results.extend([pred])
            val_labels.extend([label])
        except tf.errors.OutOfRangeError:
            break
    
    # 计算准确率等指标
    correct = [float(y == y_) for (y, y_) in zip(val_results, val_labels)]
    acc = sum(correct) / len(correct)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python2 笔记—编码问题]]></title>
        <id>https://wizyoung.github.io/post/python-encoding/</id>
        <link href="https://wizyoung.github.io/post/python-encoding/">
        </link>
        <updated>2017-09-09T06:54:38.000Z</updated>
        <summary type="html"><![CDATA[<p>初学 Python2，感觉Python2中的编码问题一直很烦人，无意中看到几篇博文 [^1] [^2]，感觉豁然开朗，做成笔记，方便日后查阅。</p>
]]></summary>
        <content type="html"><![CDATA[<p>初学 Python2，感觉Python2中的编码问题一直很烦人，无意中看到几篇博文 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，感觉豁然开朗，做成笔记，方便日后查阅。</p>
<!-- more -->
<h3 id="1-从编码谈起">1. 从编码谈起</h3>
<ul>
<li>ASCII: 全称American Strandard Code for Information Interchange。ASCII只使用了一个字节(8个比特位)来编码。且ASCII只使用了后7位，最高位位0，因此只有128个字符编码。如字符<code>A</code>对应的二进制数值为<code>01000001</code>，对应的十进制数就是65。</li>
<li>EASCII(ISO/8859-1): ASCII扩展而来，主要是考虑西欧地区的符号编码。</li>
<li>GBK: 中文编码。开始是<code>GB2312</code>，又称GB0，共收录了6763个汉字，兼容ASCII。后来扩展到<code>GBK</code>，收录了27484个汉字，同时还收录了藏文等少数名族文字。GBK也是兼容ASCII，英文字符用1个字节表示，汉字用两个字节表示。</li>
<li>Unicode: Unicode全称Universal Multiple-Octet Coded Character Set, 又简称为UCS。UCS有两种格式：UCS-2和UCS-4，顾名思义就是用2个字节和4个字节来编码。Unicode只是规定了如何编码，没有规定如何传输，保存这个编码。比如一个汉字到底是用4个字节还是3个字节来表示，依赖于具体的实现方式，如UTF-8等。</li>
<li>UTF-8: Unicode Transformation Format，Unicode的一种实现方式，是可变长字符编码，根据具体使用情况用1-4个字节来表示一个字符。</li>
</ul>
<h3 id="2-字节与字符编码与解码">2. 字节与字符，编码与解码</h3>
<ul>
<li>
<p>字节与字符：</p>
<ul>
<li>字节：计算机存储一切数据都是由一串01的字节序列构成</li>
<li>字符：就是一个符号，比如汉字，字母等</li>
</ul>
</li>
<li>
<p>编码与解码</p>
<ul>
<li>编码encode: 字符→字节。编码是为了存储和传输</li>
<li>解码decode: 字节→字符。解码是为了显示和阅读</li>
</ul>
</li>
</ul>
<h3 id="3-python2的编码问题">3. Python2的编码问题</h3>
<h4 id="31-默认编码">3.1 默认编码</h4>
<p>Python2默认用ASCII编码:</p>
<pre><code class="language-python">import sys
print sys.getdefaultencoding()  # ascii
</code></pre>
<p>就是说默认的解释器会把str类型的字符串当做ASCII编码来处理。</p>
<p>注意区分的是：文档开头往往加上一句<code># coding: utf-8</code>是来指定脚本文件的编码方式。</p>
<h4 id="32-str和unicode">3.2 str和unicode</h4>
<p>Python2中，str和unicode都是basestring的子类，可见str和unicode是两种不同类型的字符串对象。</p>
<p>以汉字“禅”为例，str打印出来就是十六进制形式的\xe7\xa6\x85，对应于一长串二进制序列；而用unicode打印出来就是unicode符号u'\u7985':</p>
<ul>
<li>str:</li>
</ul>
<pre><code class="language-shell">&gt;&gt;&gt; s = '禅'
&gt;&gt;&gt; s
'\xe7\xa6\x85'
&gt;&gt;&gt; type(s)
&lt;type 'str'&gt;
</code></pre>
<ul>
<li>unicode:</li>
</ul>
<pre><code class="language-shell">&gt;&gt;&gt; u = u'禅'
&gt;&gt;&gt; u
u'\u7985'
&gt;&gt;&gt; type(u)
&lt;type 'unicode'&gt;
</code></pre>
<p>如果要把unicode符号保存到文件，或者是传输到网络，那就必须编码为str类型；反之亦然：</p>
<ul>
<li>encode:</li>
</ul>
<pre><code class="language-shell">&gt;&gt;&gt; u = u'禅'
&gt;&gt;&gt; u
u'\u7985'
&gt;&gt;&gt; u.encode('utf-8')
'\xe7\xa6\x85'
</code></pre>
<ul>
<li>decode:</li>
</ul>
<pre><code class="language-shell">&gt;&gt;&gt; s = '禅'
&gt;&gt;&gt; s
'\xe7\xa6\x85'
&gt;&gt;&gt; s.decode('utf-8')
u'\u7985'
</code></pre>
<p>说白了：</p>
<p>编码：字符到二进制数据的转换，即: encode: unicode → str</p>
<p>解码：二进制数据到字符的转换，即: decode: str → unicode</p>
<h4 id="33-不同编码之间的转换">3.3 不同编码之间的转换</h4>
<figure data-type="image" tabindex="1"><img src="http://7xqr14.com1.z0.glb.clouddn.com/python_encoding.jpg" alt="" loading="lazy"></figure>
<p>不同的编码之间通过unicode作为中间媒介来互相转换:</p>
<p>比如一个用utf-8编码好的汉字'\xe7\xa6\x85'，要变成gbk:</p>
<pre><code class="language-shell">'\xe7\xa6\x85'.decode('utf-8').encode('gbk')
</code></pre>
<h4 id="34-unicodexxxerror-错误及原因">3.4 UnicodeXXXError 错误及原因</h4>
<ul>
<li>
<p>case1:</p>
<pre><code class="language-shell">&gt;&gt;&gt; s = '你好'
&gt;&gt;&gt; s.decode()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)
</code></pre>
<p>s.decode()默认使用ascii解码，但是ascii字符集中是没有中文字符的，因此报错: 0xe4超出范围了</p>
</li>
<li>
<p>case2:</p>
<pre><code class="language-shell">&gt;&gt;&gt; a = u'你好'
&gt;&gt;&gt; a.encode()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
</code></pre>
<p>与case1类似，unicode转换str时默认用ascii，也是报错。</p>
</li>
<li>
<p>case3:</p>
<pre><code class="language-shell">&gt;&gt;&gt; s = '你好'  # str类型
&gt;&gt;&gt; y = u'python'  # unicode类型
&gt;&gt;&gt; s + y    # 隐式转换，即 s.decode('ascii') + u
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)
</code></pre>
<p>str和unicode混用时，str会隐式地decode为unicode，然后也是由于用了ascii找不到汉字报错。这里详细见3.8节。</p>
</li>
</ul>
<h4 id="35-乱码问题">3.5 乱码问题</h4>
<pre><code class="language-shell"># coding: utf-8
&gt;&gt;&gt; a='好'
&gt;&gt;&gt; a
'\xe5\xa5\xbd'
&gt;&gt;&gt; b=a.decode(&quot;utf-8&quot;)
&gt;&gt;&gt; b
u'\u597d'
&gt;&gt;&gt; c=b.encode(&quot;gbk&quot;)
&gt;&gt;&gt; c
'\xba\xc3'
&gt;&gt;&gt; print c
��
</code></pre>
<p>utf-8编码的字符‘好’占用3个字节，解码成Unicode后，如果再用gbk来解码后，只有2个字节的长度了，最后出现了乱码的问题，因此防止乱码的最好方式就是始终坚持使用同一种编码格式对字符进行编码和解码操作。</p>
<h4 id="36-str和unicode">3.6 str()和unicode()</h4>
<p>str()和unicode()是两个工厂方法，分别返回str字符串对象和unicode字符串对象。</p>
<p>其实本质为:</p>
<p>str(s) = s.encode('ascii')</p>
<p>unicode(s) = s.decode('ascii')</p>
<pre><code class="language-shell">&gt;&gt;&gt; s3 = u&quot;你好&quot;
&gt;&gt;&gt; s3
u'\u4f60\u597d'
&gt;&gt;&gt; str(s3)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
</code></pre>
<ul>
<li>技巧:</li>
</ul>
<p>对于一个unicode形式的str字符串，如<code>\u4f60\u597d</code>这样的，如何变成真正的unicode呢?</p>
<p>最简单是前面加个u:</p>
<pre><code class="language-shell">&gt;&gt;&gt; print u'\u4f60\u597d'
你好
</code></pre>
<p>但是在像解析html时，储存在了一个字符串中，就可以这么做:</p>
<pre><code class="language-shell">&gt;&gt;&gt; s='\u4f60\u597d'
&gt;&gt;&gt; type(s)
&lt;type 'str'&gt;
&gt;&gt;&gt; s = s.decode('unicode-escape')
&gt;&gt;&gt; print s
你好
</code></pre>
<h4 id="37-检测编码">3.7 检测编码</h4>
<p>可用chardet检测字符编码:</p>
<pre><code class="language-shell">&gt;&gt;&gt; import chardet
&gt;&gt;&gt; a = '好'
&gt;&gt;&gt; print chardet.detect(a)
{'confidence': 0.73, 'language': '', 'encoding': 'ISO-8859-1'}
</code></pre>
<h4 id="38-syssetdefaultencodingutf-8的作用">3.8 sys.setdefaultencoding('utf-8')的作用</h4>
<p>Python2会在必要的情况下，对string作必要的编码类型转换，如<code>==</code>操作，字节和字符拼接，以及对str编码(encode)时。</p>
<p>看3.4的例子，我们这么操作就不会报错了:</p>
<pre><code class="language-shell">&gt;&gt;&gt; import sys
&gt;&gt;&gt; reload(sys)
&lt;module 'sys' (built-in)&gt;
&gt;&gt;&gt; sys.setdefaultencoding('utf-8')  # 初始化后删除了 sys.setdefaultencoding 方法，我们需要重新载入 
&gt;&gt;&gt; s = '你好'
&gt;&gt;&gt; y = u'python'
&gt;&gt;&gt; s + y
u'\u4f60\u597dpython'
</code></pre>
<p>s和y类型不一样，于是Python调用更改后的默认编码utf-8对s进行decode为unicode再操作。</p>
<p>再看:</p>
<pre><code class="language-shell">&gt;&gt;&gt; s='你好'
&gt;&gt;&gt; s.encode('gb2312')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)
</code></pre>
<p>直接对str进行编码，首先会解码到unicode，默认ASCII，所以报错。</p>
<p>修改的方式为改成<code>s.decode('utf-8').encode('gb2312')</code>或者加上sys.setdefaultencoding('utf-8')</p>
<p><strong>注意</strong>: 用这种方法是有潜在危害的，详见: <a href="https://blog.ernest.me/post/python-setdefaultencoding-unicode-bytes">立即停止使用 setdefaultencoding('utf-8')， 以及为什么</a></p>
<p>文中提到，好的习惯是:</p>
<blockquote>
<ul>
<li>所有 text string 都应该是 unicode 类型，而不是 str，如果你在操作 text，而类型却是 str，那就是在制造 bug。</li>
<li>在需要转换的时候，显式转换。从字节解码成文本，用 var.decode(encoding)，从文本编码成字节，用 var.encode(encoding)。</li>
<li>从外部读取数据时，默认它是字节，然后 decode 成需要的文本；同样的，当需要向外部发送文本时，encode 成字节再发送。</li>
</ul>
</blockquote>
<h4 id="39-print时的编码处理">3.9 print时的编码处理</h4>
<p>Python2.7中调用print打印出var变量时，操作系统会对var做一定的字符处理：如果var是str类型的变量，则直接将var变量交付给终端进行显示；如果var变量是unicode类型，则操作系统首先将var编码成str类型的对象，再显示。<br>
因此对于unicode中有中文，打印前一定要先encode('utf-8')之类，或者用sys.setdefaultencoding('utf-8')也行。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://foofish.net/python-unicode-error.html">Python 编码错误的本质原因</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://blog.ernest.me/post/python-setdefaultencoding-unicode-bytes">立即停止使用 setdefaultencoding('utf-8')， 以及为什么</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac 个人使用小技巧汇总]]></title>
        <id>https://wizyoung.github.io/post/Mac个人使用小技巧汇总/</id>
        <link href="https://wizyoung.github.io/post/Mac个人使用小技巧汇总/">
        </link>
        <updated>2017-08-09T11:31:12.000Z</updated>
        <summary type="html"><![CDATA[<p>手里的 15 款 MacBook Pro 使用两年下来，积累了不少使用小技巧，不同于网上烂大街分享的“玩机经验”，这些技巧大部分是基于自己的长时间使用发现和总结出来的，有些偏小众，却都很实用，今天花点时间整理一部分，日后想到更多的再补充。</p>
]]></summary>
        <content type="html"><![CDATA[<p>手里的 15 款 MacBook Pro 使用两年下来，积累了不少使用小技巧，不同于网上烂大街分享的“玩机经验”，这些技巧大部分是基于自己的长时间使用发现和总结出来的，有些偏小众，却都很实用，今天花点时间整理一部分，日后想到更多的再补充。</p>
<!-- more -->
<h3 id="1-safari-清除历史记录却不丢失网站登录信息">1. Safari 清除历史记录却不丢失网站登录信息</h3>
<p>点击任务栏 <code>Safari</code>，鼠标放在 <code>清除历史记录...</code> 上，按住 <code>Option</code> 键，该选项变成<code>清除历史记录但保留网站数据</code>。这样，将不会丢失保存网站的登录信息。</p>
<h3 id="2-safari-知乎复制文字版权问题">2. Safari 知乎复制文字版权问题</h3>
<p>知乎复制文字，经常最后面带版权小尾巴；或者禁止转载的，直接不能复制。</p>
<p>解决方法：Safari任务栏点击<code>开发</code>→<code>停用JavaScript</code>，再刷新网页即可。若无开发选项，可在Safari<code>偏好设置</code>→<code>高级</code>勾选<code>在菜单栏中显示“开发”菜单</code>。</p>
<h3 id="3-系统-window-界面动画迟滞">3. 系统 Window 界面动画迟滞</h3>
<p>感觉 MacOS Sierra 稳定性和发热的控制和 OSX 10.11 相比相差太远，尤其是 WindowServer 的动画过渡上。从 Docker 上打开 Safari，明显感觉到动画的迟滞。可用以下两条指令加快动画:</p>
<pre><code class="language-shell">defaults write NSGlobalDomain NSAutomaticWindowAnimationsEnabled -bool NO 
defaults write -g NSAutomaticWindowAnimationsEnabled -bool false
</code></pre>
<p>系统整体动画迟滞的原因还有一种可能，就是支付宝服务后台搞事，相关说明和操作详见: <a href="https://zhuanlan.zhihu.com/p/20606174">【警告】支付宝后台服务会妨害 rMBP 的显示效能（更新灭活脚本）</a></p>
<h3 id="4-字体册-fontbook-浏览卡顿">4. 字体册 Fontbook 浏览卡顿</h3>
<p>升级到 macOS Sierra 后，发现字体册 Fontbook 浏览字体明显卡顿，曾以为是系统特色，后来发现其实重置相关设置就好。在Finder中删除 <code>~/Library/Preferences/com.apple.FontBook.plist</code> 即可。</p>
<h3 id="5-finder-打开卡顿缓慢">5. Finder 打开卡顿缓慢</h3>
<p>遇到 Finder 打开速度极其缓慢，半天才显示文件，也是重置相关设置就好：删除 <code>~/Library/Preferences/com.apple.finder.plist</code> 后重启Finder。</p>
<p>其实，哪个软件出了问题，删除 <code>~/Library/Preferences/</code> 下对应的plist文件重置就好。</p>
<h3 id="6-合盖休眠耗电问题">6. 合盖休眠耗电问题</h3>
<p>经 <a href="https://www.v2ex.com/t/361578#reply5">V2EX</a> 讨论，证实为 WiFi TCP Keep Alive 耗电，最简单的设置是终端执行:</p>
<pre><code class="language-shell">sudo pmset -a tcpkeepalive 0
</code></pre>
<p>亲测执行此命令后，合盖一晚，掉电为 0。</p>
<h3 id="7-终端走代理">7. 终端走代理</h3>
<p>可能很多人推荐使用<code>Proxychains-ng</code>，个人觉得还是麻烦。考虑到我使用 zsh 和 surge，因此我的解决方案是: 在 <code>~/.zshrc</code> 中添加指令:</p>
<pre><code class="language-shell">proxy(){
	export https_proxy=&quot;http://127.0.0.1:localport&quot;
	export http_proxy=&quot;http://127.0.0.1:localport&quot;
	echo &quot;HTTP Proxy on&quot;
}

noproxy(){
	unset http_proxy
	unset https_proxy
	echo &quot;HTTP Proxy off&quot;
}
</code></pre>
<p>终端中键入 <code>proxy</code> 即可打开代理，键入 <code>noproxy</code> 可关闭代理。</p>
<h3 id="8-风扇全速运转时cpu降速">8. 风扇全速运转时CPU降速</h3>
<p>[本条来自某锁推的推主] 风扇全速运转时，macOS 会调用 kernel_task 给 CPU 降速，最终导致系统整体迟滞，解决方案是在禁用 SIP 的情况下删除 <code>/System/Library/Extensions/IOPlatformPluginFamily.kext</code> 后重启。详细可参见 <a href="https://www.davidschlachter.com/misc/kernel_task">Disable OS X kernel_task throttling</a>.</p>
<h3 id="9-appstore-下载慢">9. AppStore 下载慢</h3>
<p>在正在下载的 App 上点击使下载暂停，然后清除 DNS 缓存，再点击继续下载，只要 Apple 服务器和本地网络没问题，速度马上飚满带宽。</p>
<h3 id="10-onenote-同步缓慢">10. OneNote 同步缓慢</h3>
<p>OneNote 经常同步出错，或者同步缓慢，根据 MS 官方建议，使用 DNS 4.2.2.1 或 4.2.2.2 即可，然而将其用作备 DNS 简直就是扯淡（备用 DNS 上场的机会都没有）。即使使用了优质梯子还是慢。还好我们有Surge，只需要让 Surge 指定 OneNote 同步的服务器使用 4.2.2.1 或者 4.2.2.2 作为 DNS 就好：在 Surge 配置文件中增加以下几行:</p>
<pre><code>[Host]
d.docs.live.net = server:4.2.2.1
www.onenote.com = server:4.2.2.1
*.microsoft.com = server:4.2.2.1
*.live.com = server:4.2.2.1
</code></pre>
<p>再出现同步慢你来打我.</p>
<h3 id="11-omnigraffle-不支持数学公式">11. OmniGraffle 不支持数学公式</h3>
<p>下载 LaTeXiT，键入 LaTeX 生成公式后，直接拖进 OmniGraffle 就好，选择矢量图形，双击还能回到 LaTexiT 编辑。</p>
<h3 id="12-保持当前窗口最前操作后面的窗口">12. 保持当前窗口最前操作后面的窗口</h3>
<p>按住 <code>Cmd</code> 键再点击操作后面的窗口即可。这个操作非常实用，比如复制后面浏览器中的问题到当前的文本编辑器中，这样鼠标选中后面浏览器中的文字复制时，最前的的编辑器窗口并不会消失。</p>
<h3 id="13-百度云下载限速">13. 百度云下载限速</h3>
<p><strong>已失效</strong> 浏览器使用<a href="https://github.com/acgotaku/BaiduExporter">BaiduExporter</a>或者<a href="https://greasyfork.org/scripts/31921-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B">相关油猴脚本</a>解析导出真实地址再用多线程工具下载。大部分人偏向于使用<a href="https://aria2.github.io">Aria2</a>下载，但是本人更偏好轻量的<a href="https://github.com/eribertomota/axel">Axel</a>，命令行呼出就可用:  <code>axel -n num_of_connections -a download_link</code></p>
<p>亲测20M带宽下，开30+线程，能直接跑满带宽。</p>
<h3 id="14-右键中有重复或者已卸载软件的快捷方式">14. 右键中有重复或者已卸载软件的快捷方式</h3>
<p>终端执行:</p>
<pre><code class="language-shell">/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local -domain system -domain user
</code></pre>
<p>然后重启。</p>
<h3 id="15-mission-control-动画太慢">15. Mission Control 动画太慢</h3>
<p>升级到 macOS Sierra 后，Mission Control 动画是在太慢，影响效率。可到系统设置的触控板设置中，关闭自带的 Mission Control 手势，然后转用第三方软件 Jitouch 的 Mission Control。</p>
<h3 id="16-查看某-app-支持的-applescript-脚本">16. 查看某 App 支持的 AppleScript 脚本</h3>
<p>日常编写 AppleScript 完成一些自动化操作时，却不知道某些 App 支持哪些 AppleScript 脚本，其实 macOS 提供了一个很隐蔽的方式来查看：打开脚本编辑器，任务栏点击<code>文件</code>→<code>打开词典...</code>，再选择目标 App 即可.</p>
<h3 id="17-popclip-在某些应用中弹不出来">17. Popclip 在某些应用中弹不出来</h3>
<p>Popclip 是个极好的软件，然而，有些 App 中，由于适配原因，鼠标选中文字后并不能弹出 Popclip 插件条，这时可借助 BetterTouchTool 软件强行让 Popclip 弹出来:</p>
<p>建立一个 .scpt 脚本，里面填入 <code>tell application &quot;PopClip&quot; to appear</code> 保存。然后在 BetterTouchTool 新建一个 Gesture (触摸板手势我选择的是 3 Fingers Swipe Up)，<code>Predefined Action</code> 中选择 <code>Open Application / File / Apple Script ...</code>，在弹出的窗口选中刚才那个 scpt 脚本。这样，每当鼠标选中文字，Popclip 插件条不出来的时候，三个手指在触摸板上顺势网上一推，插件条就强行被手动唤出了.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[提高效率第二弹之自己开发谷歌翻译 popclip 插件]]></title>
        <id>https://wizyoung.github.io/post/提高效率第二弹之自己开发谷歌翻译popclip插件/</id>
        <link href="https://wizyoung.github.io/post/提高效率第二弹之自己开发谷歌翻译popclip插件/">
        </link>
        <updated>2017-08-04T15:17:14.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>根据 Google Translate 开发的 Popclip 插件，响应速度是我用过的翻译插件里最快的，可以选择翻译源（.com .cn），有多种国外语言可以翻译，点击按钮后在屏幕右上方显示译文。                           ——<a href="https://www.waerfa.com/what-apps-are-frank-playing-eposide-4">MAC玩儿法</a>报道</p>
</blockquote>
<p>继上次自己开发 Alfred Workflow 后，这次我又盯上了 popclip。</p>
<p>事因是自己一直渴望有一种完美的谷歌翻译使用方式，目的是用鼠标选中待选定句子，然后弹出谷歌翻译内容。无奈一直没人做，只好自己动手实现。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>根据 Google Translate 开发的 Popclip 插件，响应速度是我用过的翻译插件里最快的，可以选择翻译源（.com .cn），有多种国外语言可以翻译，点击按钮后在屏幕右上方显示译文。                           ——<a href="https://www.waerfa.com/what-apps-are-frank-playing-eposide-4">MAC玩儿法</a>报道</p>
</blockquote>
<p>继上次自己开发 Alfred Workflow 后，这次我又盯上了 popclip。</p>
<p>事因是自己一直渴望有一种完美的谷歌翻译使用方式，目的是用鼠标选中待选定句子，然后弹出谷歌翻译内容。无奈一直没人做，只好自己动手实现。</p>
<!-- more -->
<h2 id="1-使用效果展示">1. 使用效果展示</h2>
<p>展示一下最终的自制 popclip 谷歌翻译插件使用效果:</p>
<p>首先设置里面有几个选项可以设置:</p>
<figure data-type="image" tabindex="1"><img src="https://wizyoung.github.io/post-images/1581672359730.jpg#w70" alt="" loading="lazy"></figure>
<ul>
<li><code>Google Translate Site</code>: 可选 <code>translate.google.cn</code> 和 <code>translate.google.com</code> 作为翻译服务器，前者给墙内的朋友使用，后者则是给墙外的使用。</li>
<li><code>Destination Language</code> 和 <code>Source Language</code>: 目标外语 (destination language) 和母语 (source language)。程序将对划中的语言进行检测，若检测的语言非母语，则翻译为母语；若检测的语言为母语，则翻译为目标外语。</li>
</ul>
<p>使用效果GIF：</p>
<p>英译中:</p>
<figure data-type="image" tabindex="2"><img src="https://wizyoung.github.io/post-images/1581672455232.gif" alt="" loading="lazy"></figure>
<p>中译英:</p>
<figure data-type="image" tabindex="3"><img src="https://wizyoung.github.io/post-images/1581672474906.gif" alt="" loading="lazy"></figure>
<p>确实很方便~</p>
<h2 id="2-为什么选择popclip">2. 为什么选择popclip</h2>
<p>其实 Mac 上的翻译方案很多，在本插件出来之前，个人觉得最好用的当属 <a href="http://translate-tab.com">Translate Tab</a>了，鼠标选中待翻译字段，点击其 popclip 图标，然后通知栏弹出翻译：</p>
<figure data-type="image" tabindex="4"><img src="https://wizyoung.github.io/post-images/1581672764624.png" alt="" loading="lazy"></figure>
<p>然而 Translate Tab 也是有缺点的：</p>
<ul>
<li>收费 (其实就是简单封装了一下 google translate 网页版）</li>
<li>通过 popclip 选择文字这种调用方式，第一次打开很慢，经常转了无数圈，结果才翻译出来</li>
<li>服务器只能走 <code>translate.google.com</code>，不翻墙无法使用。我给开发者发邮件，开发者回复道 <code>Theoretically google must redirect app to the domain according to geolocation. I will check this moment</code>，然后我再回复就没有后文了。。。如果用 Surge 的 URL Rewrite 功能设置<code>translate.google.com</code> 跳转到 <code>translate.google.cn</code>，需要开启 MitM，比较浪费性能。</li>
</ul>
<p>因为我非常喜欢 popclip 这种形式的小软件，因此决定转入 popclip 插件开发。popclip 官方 API 提供了一种 <code>show-result</code> 形式的 GUI 显示文本，然而效果实在太挫了：只能在屏幕中像下面一样显示一长条，不支持换行，太长了就自动截断了，也是让人很醉：</p>
<figure data-type="image" tabindex="5"><img src="https://wizyoung.github.io/post-images/1581672965135.png#w90" alt="" loading="lazy"></figure>
<p>一开始我使用的方案是采用第三方 <a href="http://mstratman.github.io/cocoadialog/">cocoaDialog</a> 做结果显示 GUI，做了右上角弹出 Bubble 或者屏幕中央弹出 Msgbox 的方式。使用几个版本后还是抛弃了 cocoaDialog，因为弹出的 MsgBox 30 秒后自动消失，往往翻译结果还没看完就消失了。研究 AppleScript 时发现自带的 osascript 提供了 dialog 的组件显示文本，非常好用。就是 dialog 要显示自定义图标文件全网缺少相关文档，找的方案基本不可行，硬是被自己试出来。。。</p>
<h2 id="3-调用谷歌翻译">3. 调用谷歌翻译</h2>
<p>如何调用谷歌翻译，我第一反应当然是爬虫，然而用 Chrome 到 translate.google.cn 抓包一看：</p>
<figure data-type="image" tabindex="6"><img src="https://wizyoung.github.io/post-images/1581674609602.png#w80#h30" alt="" loading="lazy"></figure>
<p>上图中的 Request URL 中有一个 tk 值，这个值是根据输入的文字调用 JavaScript 计算的，代码经过了非常复杂的混淆包装，几万行代码就为了混淆一个 tk 值，太可怕了。。。</p>
<p>那就试试谷歌官方的收费 API 吧。于是我去开通了 Google Cloud，绑定了信用卡，然后发现新用户居然赠送 300 美金优惠券（限一年用完）！激动！另外，谷歌翻译官方 API 使用方式也很简单，用自己的 API KEY 组合成这样一个 URL: <code>https://translation.googleapis.com/language/translate/v2?key=' + API_KEY</code>，然后把 <code>{'target':target_lang, 'q': query}</code> post 上去，就可以得到结果。不需要科学上网，速度也是超级快。然而谷歌计费方式是每 1 M 个 characters 收费 20 美金，我在写代码过程中就随便小测了一下，居然用了 3 K 个 characters，所以这个 characters 咋算的，字母数么。。。要是分享出去用的人多了，用不了几天 300 美金就花光了。</p>
<p>然后我又去搜索，有没有免费的谷歌翻译 API，果然在知乎找到了: <a href="https://www.zhihu.com/question/47239748?sort=created">请问如何调用谷歌翻译API?</a>。用 <code>http://translate.google.cn/translate_a/single?client=gtx&amp;amp;amp;amp;sl=en&amp;tl=zh-CN&amp;dt=t&amp;q=query</code> 的形式去查询就可以免费调用谷歌翻译。难道是漏网之鱼？不一会我就发现，woc，同一 IP 下调用此 API 多次就直接被 Google 给 ban 了！心机你 Google！</p>
<p>好在 GitHub 大神多，一通搜索，有人逆向了谷歌的 tk，还封装好了😅: <a href="https://github.com/ssut/py-googletrans">py-googletrans</a>。好了，既然有现成的轮子了，我就直接用了~</p>
<h2 id="4-popclip-插件的编写">4. popclip 插件的编写</h2>
<p>虽说第一次接触 popclip 插件的编写，小试一下，发现还是蛮简单的。写起来比 Alfred Workflow 简单不少，然而没法调试，略蛋疼。全程主要参考了少数派 <a href="https://sspai.com/post/26154">让剪切板在 OS X 上飞起来：PopClip 插件编写教程</a> 和 popclip 官方 <a href="https://github.com/pilotmoon/PopClip-Extensions">github documentation</a>。</p>
<p>一个 popclip 插件，主要包括三部分:</p>
<ul>
<li>Config.plist: 属性列表文件。其实类似于 Python 的字典，主要是用 key-value 的形式，设置变量。这里面最重要的两个主 key 就是 Actions 和 Options。Actions 决定了对鼠标选中的文字如何去传参和处理，如何去调用 Shell Script 或 Apple Script 来执行你想要的功能，以及如何输出。Options 则是处理设定框中的选项，是勾选框还是多选栏。具体的细节官方文档一看就懂。下图是本插件 Config.plist 的一部分截图:</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://wizyoung.github.io/post-images/1581676180458.jpg#s70" alt="" loading="lazy"></figure>
<ul>
<li>
<p>Icon.png: 图标文件。这么好的功能当然要有个卡哇伊的图标啦。</p>
</li>
<li>
<p>Script: 脚本文件。执行目标功能。popclip 默认只支持 Shell Script 和 Apple Script。要用其他语言，也只能通过这两种 Script 来调用。</p>
</li>
</ul>
<p>其实，最终实现谷歌翻译的 Python 脚本很简单，一共才 60 余行代码，和上次那个优越加速 Alfred Workflow 几百行相比简单太多，逻辑上也更简单。</p>
<p>首先我的 <code>translate.py</code> 通过 <code>argparse</code> 接受以下几个参数:</p>
<pre><code class="language-python">--site site_arg --srclang srclang_arg --destlang destlang_arg
</code></pre>
<p>然后通过 <code>go.sh</code> 来执行此 py 文件：</p>
<pre><code class="language-shell">/usr/bin/python translate.py --site $POPCLIP_OPTION_SITE  --destlang $POPCLIP_OPTION_DESTLANG --srclang $POPCLIP_OPTION_SRCLANG $POPCLIP_URLENCODED_TEXT &amp;
</code></pre>
<p>上面的 <code>$POPCLIP_XXX</code> 是 popclip 传递来的变量。以 <code>--site</code> 为例，在上面提到的 Config.plist文件的 Options 中，我设置了一个标题为 <code>Google Translate Site</code> 的多选栏，设定一个变量，其 <code>key</code> 设定为 <code>site</code>，<code>value</code> 设定为 <code>translate.google.cn</code> 或 <code>translate.google.com</code> (都是字符串)，靠用户来选择使用哪个 value。然后选定的 value 以名为 <code>$POPCLIP_OPTION_SITE</code> 的变量存在于整个插件运行的过程中，可随时调用。同样的，<code>$POPCLIP_OPTION_LANG</code> 代表 <code>Target Foreign Language</code> 那一栏的变量的 value，这里的详细设置参见我的 <a href="https://github.com/wizyoung/googletranslate.popclipext/blob/master/src/Config.plist">Config.plist</a>。</p>
<p>然后有必要交代一下最后那个 <code>$POPCLIP_URLENCODED_TEXT</code>。如何去把鼠标选中的文字转换成一个变量，传递给脚本呢。</p>
<p>起初，我是在 Config.plist 中的 Actions 中是这么设定的:</p>
<pre><code class="language-shell">&lt;key&gt;Before&lt;/key&gt;
&lt;string&gt;copy&lt;/string&gt;
</code></pre>
<p>然后用的变量名为 <code>$POPCLIP_TEXT</code>。Before 指的是在 popclip 执行主要 action 之前要干的事，这里我设定为 <code>copy</code>。这样，只要鼠标选中一段文字，将自动执行 <code>Command + C</code>，同时以 string 的形式保存为一个名叫 <code>$POPCLIP_TEXT</code> 的变量。这样的弊端也是显而易见的，每次鼠标划词都复制文字到剪切板，会扰乱剪切板。因此我改用:</p>
<pre><code class="language-shell">&lt;key&gt;Requirements&lt;/key&gt;
&lt;string&gt;copy&lt;/string&gt;
</code></pre>
<p>根据官方说明，这种情况下的 <code>copy</code> 就不会复制文字到剪切板了。另外之所以用 <code>$POPCLIP_URLENCODED_TEXT</code>，是因为坑爹的 <code>$POPCLIP_TEXT</code>，在遇到空格时就会停止复制，比如鼠标选中了 <code>a b c</code>，其实变量只存了 <code>a</code>。所以只好用 url-encoded 的形式，最后再用 urllib 库的 unquote 转换为正常的 String。</p>
<p>最后，整体流程框图如下：</p>
<figure data-type="image" tabindex="8"><img src="https://wizyoung.github.io/post-images/1581676446096.png#w90#h30" alt="" loading="lazy"></figure>
<p>整体下来思路还是挺清晰的。然后只需要把以上所有文件放在一个文件夹中，强行加上一个 <code>.popclipext</code> 就大功告成啦~</p>
<h2 id="5-代码与下载">5. 代码与下载</h2>
<p>虽然代码很简单，开源到 GitHub 了，方便一下其他人参考编写 popclip 吧~</p>
<p><mark><a href="https://github.com/wizyoung/googletranslate.popclipext">Github Repo</a></mark></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息熵，相对熵，交叉熵的理解]]></title>
        <id>https://wizyoung.github.io/post/信息熵，相对熵，交叉熵的理解/</id>
        <link href="https://wizyoung.github.io/post/信息熵，相对熵，交叉熵的理解/">
        </link>
        <updated>2017-05-01T17:33:07.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-香农信息量">1. 香农信息量</h2>
<p>信息量可以理解为不确定性的多少。</p>
<p>香农信息量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>p</mi></mfrac><mo>=</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">=log \frac{1}{p}=-logp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">p</span></span></span></span> (以 2 为底)</p>
<p>上式中，p 越小，则不确定性越大，包含的信息量就越多。比如 32 支球队，在无任何先验信息的前提下，用二分法猜冠军队伍，最多猜 5 次，也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mn>32</mn></mfrac><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">log {1\over32}=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>。</p>
<p>香农信息量的单位是比特 (bit)。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-香农信息量">1. 香农信息量</h2>
<p>信息量可以理解为不确定性的多少。</p>
<p>香农信息量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>p</mi></mfrac><mo>=</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">=log \frac{1}{p}=-logp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">p</span></span></span></span> (以 2 为底)</p>
<p>上式中，p 越小，则不确定性越大，包含的信息量就越多。比如 32 支球队，在无任何先验信息的前提下，用二分法猜冠军队伍，最多猜 5 次，也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mn>32</mn></mfrac><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">log {1\over32}=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>。</p>
<p>香农信息量的单位是比特 (bit)。</p>
<!-- more -->
<h2 id="2-信息熵-entropy">2. 信息熵 (Entropy)</h2>
<p>信息熵：香农信息量的期望</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>X</mi><mo>)</mo><mo>=</mo><mo>−</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></munder><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H(X) = -\sum_{x\in X}p(x)log p(x )
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3717110000000003em;vertical-align:-1.321706em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>信息熵的一种解释是，它表示的是最短的平均编码长度。</p>
<p>同样的，不确定性越大，熵就越大。</p>
<h2 id="3-相对熵relative-enrtopy">3. 相对熵(Relative Enrtopy)</h2>
<p>又叫 KL 散度(Kullback-Leibler Divergence)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>L</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>g</mi><mo>(</mo><mi>X</mi><mo>)</mo><mo>)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></munder><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">KL(f(x)||g(X))=\sum_{x \in X}f(x)\cdot log{f(x) \over g(x)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3717110000000003em;vertical-align:-1.321706em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<p>它用来衡量两个数值为<strong>正数</strong>的函数的相似性。</p>
<p>很容易证明，有三个结论：</p>
<blockquote>
<p>(1) 两函数完全相同时，KL=0<br>
(2) KL越大，差异越大<br>
(3) 对概率分布或者概率密度函数 (&gt;0), KL 可用来衡量两个随机变量分布的差异性</p>
</blockquote>
<p>注意，KL 散度是不对称的，因此琴生和香农提出以下计算方法：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>S</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>[</mo><mi>K</mi><mi>L</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><mi>K</mi><mi>L</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">JS(f(x)||g(x))=\frac{1}{2}[KL(f(x)||g(x)+KL(g(x)||f(x)))]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>
<h2 id="4-交叉熵-cross-entropy">4. 交叉熵 (Cross-Entropy)</h2>
<p>对一随机事件，其真实概率分布为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>，从数据中得到的概率分布为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>，则我们定义，交叉熵为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>)</mo><mo>=</mo><mo>∑</mo><mi mathvariant="normal">_</mi><mi>i</mi><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo><mfrac><mn>1</mn><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>q</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></mfrac><mo>=</mo><mo>−</mo><munder><mo>∑</mo><mi>i</mi></munder><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mi>q</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">H(p,q)= \sum\_{i}p(i)\frac{1}{logq(i)}=-\sum_{i}p(i)log{q(i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord"><span class="mord mathdefault">i</span></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>理解：</p>
<p>我们用 p 来衡量识别一个样本的信息量，也就是最小编码长度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>p</mi><mo>)</mo><mo>=</mo><mo>∑</mo><mi>p</mi><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">H(p)=\sum p log{1 \over p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>我们用 q 来估计真实分布为p的样本的信息量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>)</mo><mo>=</mo><mo>∑</mo><mi>p</mi><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mi>q</mi></mfrac></mrow><annotation encoding="application/x-tex">H(p,q)=\sum p log \frac{1}{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>则估算多出来的冗余信息量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>p</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>q</mi><mo>)</mo><mo>=</mo><mi>H</mi><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>)</mo><mo>−</mo><mi>H</mi><mo>(</mo><mi>p</mi><mo>)</mo><mo>=</mo><mo>∑</mo><mi>p</mi><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mi>p</mi><mi>q</mi></mfrac></mrow><annotation encoding="application/x-tex">D(p||q)=H(p,q)-H(p)=\sum p log{p \over q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2311079999999999em;vertical-align:-0.481108em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>（正好就是KL散度啊）</p>
<p>在机器学习中，p 通常设定为真实标记的分布，q 设定为训练后模型预测标记的分布。</p>
<p>很容易发现：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>)</mo><mo>=</mo><mi>H</mi><mo>(</mo><mi>p</mi><mo>)</mo><mo>+</mo><msub><mi>D</mi><mrow><mi>K</mi><mi>L</mi></mrow></msub><mo>(</mo><mi>p</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H(p,q)=H(p)+D_{KL}(p||q)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></span></p>
<p>即：<strong>交叉熵=信息熵+KL散度（相对熵）</strong></p>
<p>由于信息熵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span> 是固定不变的，因此我们在机器学习中就用交叉熵作为损失函数。常见的做法是先用 Softmax 函数将神经网络的结果转换为概率分布，然后用交叉熵刻画估算的概率分布与真实的概率分布的“距离”。</p>
<p>显然，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>)</mo><mo>≥</mo><mi>H</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H(p,q) \ge H(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></p>
<p>可由吉布斯不等式证明得到：</p>
<blockquote>
<p>x&gt;0时，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>n</mi><mi>x</mi><mo>≤</mo><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">lnx \le x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
因此，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi>p</mi><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mi>p</mi><mi>q</mi></mfrac><mo>=</mo><mo>−</mo><mo>∑</mo><mi>p</mi><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mi>q</mi><mi>p</mi></mfrac><mo>≥</mo><mo>−</mo><mo>∑</mo><mi>p</mi><mo>(</mo><mfrac><mi>q</mi><mi>p</mi></mfrac><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum p log {p \over q}=-\sum p log{q \over p} \ge -\sum p({q \over p} -1)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2311079999999999em;vertical-align:-0.481108em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2311079999999999em;vertical-align:-0.481108em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2311079999999999em;vertical-align:-0.481108em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br>
等号当且仅当在 p 和 q 分布完全一致时成立 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><msub><mi>q</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i=q_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</p>
</blockquote>
<hr>
<p>参考资料：</p>
<p><a href="https://book.douban.com/subject/10750155/">《数学之美--吴军》</a></p>
<p><a href="https://en.wikipedia.org/wiki/Information_theory">Wikipedia: Information theory</a></p>
<p><a href="https://en.wikipedia.org/wiki/Cross_entropy">Wikipedia: Cross entropy</a></p>
<p><a href="https://en.wikipedia.org/wiki/Gibbs%27_inequality">Wikipedia: Gibbs's inequality</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu下GTX1080显卡驱动折腾小记]]></title>
        <id>https://wizyoung.github.io/post/Ubuntu下GTX1080显卡驱动折腾小记/</id>
        <link href="https://wizyoung.github.io/post/Ubuntu下GTX1080显卡驱动折腾小记/">
        </link>
        <updated>2017-03-01T16:30:35.000Z</updated>
        <summary type="html"><![CDATA[<p>最近开始入深度学习的坑，给实验室电脑装 Ubuntu 系统和 GTX1080 显卡驱动，遇到不少坑，其中最大的问题是装完显卡驱动后开机登录输入密码显示不正确，然后陷入无限循环登录的无解状态。网上教程无数，然而通过本人近两天的逐个测试，其实一个靠谱的解决方案都没有，只能靠自己控制变量法 + Google + 大胆猜想折腾出解决方案，一路下来真的是十分曲折，无比艰辛。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近开始入深度学习的坑，给实验室电脑装 Ubuntu 系统和 GTX1080 显卡驱动，遇到不少坑，其中最大的问题是装完显卡驱动后开机登录输入密码显示不正确，然后陷入无限循环登录的无解状态。网上教程无数，然而通过本人近两天的逐个测试，其实一个靠谱的解决方案都没有，只能靠自己控制变量法 + Google + 大胆猜想折腾出解决方案，一路下来真的是十分曲折，无比艰辛。</p>
<!-- more -->
<blockquote>
<p>硬件平台：i7-6700K CPU, GTX1080 GPU, 华硕 Z170 主板<br>
软件平台: Ubuntu 16.04</p>
</blockquote>
<p>先看看网上最流行的3个不靠谱解决方案：</p>
<ul>
<li>更改 /etc/profile 环境变量，更改 Xauthority 文件权限等 <a href="http://www.tuicool.com/articles/IBreErY">链接</a></li>
<li>显卡驱动 .run 文件添加 --no-opengl-files 参数 <a href="http://www.cnblogs.com/Qwells/p/6086773.html">链接</a></li>
<li>.run 文件有 bug，改用 .deb 文件安装 <a href="https://zhuanlan.zhihu.com/p/21434933?refer=intelligentunit">链接</a></li>
</ul>
<p>基于我自己和我身边朋友的经历，以上三个方法<strong>根本无法解决</strong>开机无限登录的问题。</p>
<p>其实当我走完了所有流程后发现，其实出现安装失败，无限重启的根由是：<strong>安装独显驱动的时候不要让独显处于被占用状态</strong>，否则出错。什么叫被占用状态呢？当你把显示器的线( 通过HDMI 或者 DP口)<strong>接在独显</strong>上，一旦开机<strong>图形系统被自动后台启用</strong>后，独显就被占用了。</p>
<p>那么解决的方案其实很简单：</p>
<ul>
<li>对于 Intel 系列如 i7-6700K 这样自带集显的 CPU，可以通过<strong>拔线法</strong>配合后面的<strong>系统设置附加驱动安装法</strong>解决，这样最简单。也就是说，在装 N 卡驱动前，把显示器连接线一直插在 CPU 集显口上，驱动装完后再把线接回到独显上。</li>
<li>对于 AMD 系列 CPU，很多都不带集显，显示器的线就只能插在独显口上。这种情况下得用后文的 <strong>ppa法</strong> 或者 <strong>.run文件</strong> 法安装驱动，也就是安装驱动时保持关闭系统图形界面，使独显自始至终不被占用。ppa法或者.run文件法是通用方法，适用于所有CPU。</li>
</ul>
<p>以下是稍详细的方案说明：</p>
<h3 id="1-安装ubuntu系统">1. 安装Ubuntu系统</h3>
<p>这里我安装的是 Ubuntu 16.04 系统。若在安装过程中遇到开机黑屏，或者显示器提示频率超出范围，在开机时修改 grub 设置即可：开机时狂按键盘上的<code>e</code>键，进入 grub 编辑界面，在 quiet splash 后面加上 nomodeset。添加该参数的目的是让内核在加载 X11 Window 系统前不要加载视频驱动程序，转而采用基本的 BIOS 模式，避免前面的黑屏等不兼容情况出现。</p>
<h3 id="2-屏蔽开源驱动-nouveau">2. 屏蔽开源驱动 nouveau</h3>
<p>Nouveau 是 Linux 诸多发行版为 Nvidia 显卡提供的默认开源驱动程序，在显示效能上当然比不上 Nvidia 官方提供的默认驱动。因此，首先我们要卸载这个开源驱动，为安装官方闭源驱动做准备。</p>
<p>打开终端执行 (下面以 gedit 文本编辑器为例)：</p>
<pre><code class="language-shell">sudo gedit /etc/modprobe.d/blacklist-nouveau.conf
</code></pre>
<p>在新增的文件中写入以下内容保存:</p>
<pre><code class="language-shell">blacklist nouveau
blacklist lbm-nouveau
options nouveau modeset=0
alias nouveau off
alias lbm-nouveau off
</code></pre>
<p>然后在终端中执行:</p>
<pre><code class="language-shell">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf
sudo update-initramfs -u
</code></pre>
<p>检查 nouveau 开源驱动是否屏蔽成功:</p>
<pre><code class="language-shell">lsmod | grep nouveau
</code></pre>
<p>若无内容输出，则说明 nouveau 已经屏蔽成功，可以进行下一步操作了，否则仔细检查以上操作有无操作上的失误。</p>
<h3 id="3-安装n卡驱动">3. 安装N卡驱动</h3>
<p>安装驱动的方式有好几种，比如系统设置附加驱动安装法，官方 .run 驱动文件安装法，ppa 法和自行编译法。这里将前三种都大概讲一下，根据情况任选其一即可。</p>
<h4 id="31-系统设置附加驱动安装法">3.1 系统设置附加驱动安装法</h4>
<p><strong>注意：这种方法仅适用于拔线法，不适用于没有集显的CPU使用。因为这种方法是在图形界面里执行的，而没有集显口可用的情况下，独显是一直被占用的。</strong></p>
<p>在系统设置里面更新软件源缓存列表后，在附加驱动里面勾选类似于 Nvidia-387 字样的私有驱动进行安装，装完重启电脑即可。</p>
<p>这一步若遇到安装 N 卡驱动时进度条一直卡在最后走不满的情况，可进终端用 top 指令查看是什么进程在占用 CPU。若是 aptd 进程长时间占用 100% CPU，在系统设置里面关闭所有系统更新相关的设置即可解决。</p>
<h4 id="32-ppa-安装法">3.2 ppa 安装法</h4>
<p>首先大致介绍一下 Ubuntu 的桌面图形系统的运作方式和相关概念。第一个概念是 DE (desktop environment), 即桌面环境，可以理解为整个图形界面的 GUI 显示模式，不同的 Ubuntu 定制版和同一定制版的不同版本采用的 DE 可能都不一样，常见的 DE 有界面简洁但是资源占用少的 Xfce，Ubuntu 14 和16 都采用的 Unity，以及 Ubuntu 17 后开始采用的 gnome 等等。第二个概念是 DM (Display Manager), 前面提到了 DE，用于管理 DE 的软件就是 DM 了，比如可以同时安装多个 DE，用 DM 去手动切换。Ubuntu 16 采用的 DM 叫 lightdm。</p>
<p>因此，这里安装显卡驱动时，我们直接把整个 DM 关闭掉就不会让 DE 占用独显了。DM 的存放位置在 <code>/etc/init.d/</code> 文件夹下，里面一般带 dm 后缀的就是系统默认 DM 了。</p>
<p><code>ctrl</code>+<code>alt</code>+<code>F1</code>进入文本模式：</p>
<p>关闭图形界面：</p>
<pre><code class="language-shell">sudo /etc/init.d/lightdm stop
</code></pre>
<p>添加 ppa 源并更新缓存:</p>
<pre><code class="language-shell">sudo add-apt-repository ppa:graphics-drivers/ppa
sudo apt-get update
</code></pre>
<p>安装驱动:</p>
<pre><code class="language-shell">sudo apt-get install nvidia-xxx  # xxx是版本号，这里按tab选择版本即可
</code></pre>
<p>重启电脑或重新打开图形界面(sudo /etc/init.d/lightdm start, 然后 ctrl alt F6进入图形界面)</p>
<h4 id="33-run文件安装法">3.3 run文件安装法</h4>
<p>Nvidia 提供的驱动文件格式是 .run 后缀的，去官网下载对应的驱动文件，然后按照 ppa 法关闭图形环境，在文本模式输入：</p>
<pre><code class="language-shell">chmod a+x a.run  # a.run为驱动文件
sudo sh ./a.run
</code></pre>
<p>装完重启或者重新打开图形界面。</p>
<h4 id="34-出错重来">3.4 出错重来</h4>
<p>如果操作过程中发现安装出错了要重新装驱动，首先得卸载驱动残余，再重新安装驱动：</p>
<pre><code class="language-shell">sudo apt-get remove --purge nvidia*
sudo apt-get autoremove
sudo reboot
</code></pre>
<p>注: .run文件安装的驱动最好上面卸载可能不干净，最好先执行: <code>sudo /usr/bin/nvidia-uninstall</code></p>
<h4 id="35-装完检查">3.5 装完检查</h4>
<p>上述几种方法安装完驱动后，开机进入系统，屏幕右上角点击关于此计算机，图形一栏应该会显示这是NVIDIA 的显卡，说明独显驱动已安装成功。若仍然显示为 Intel 集显，可尝试手动切换到独显：</p>
<pre><code class="language-shell">sudo prime-select nvidia
</code></pre>
<p>这时再输入指令：</p>
<pre><code class="language-shell">prime-select query
</code></pre>
<p>若显示 <code>nvidia</code> 说明已切换到独显，但是要重启才能生效。</p>
<p>如果这一步仍然失败，一定是前面哪一步出错了。</p>
<h3 id="4-对于华硕主板配合拔线法安装的说明">4. 对于华硕主板配合拔线法安装的说明</h3>
<p>在拔线法的情况下，安装 N 卡独显驱动前，需要把显示器线接在集显口上。然而<strong>某些</strong>华硕主板设置是<strong>默认关闭集显</strong>的，因此要先在主板设置中将其打开并暂时将优先级设为最高，再插线到集显接口，否则该接口无法使用。</p>
<p>更改方法：</p>
<p>开机时进入BIOS设置，依次进入 Advanced—&gt;System Agent Configuration—&gt;Graphics Configuration中，将 iGPU 设为开启，然后 Primary Display 设为 IGFX，保存重启。再把视频线接到主板上 CPU 那儿的集显接口上，开机进入 Ubuntu 系统。</p>
<p>根据第 3 部分教程安装完独显驱动后，再把显示器线接到独显口上，这时再去主板中启用独显：</p>
<p>上一步的步骤中把 Primary Display 设置为 PCIE 或者 Auto</p>
<h3 id="5-总结">5. 总结</h3>
<p>总结起来一句话：给独显装驱动的时候，不要占用独显。凡是线插在独显口，又进入 GUI 图形界面操作的，一定失败！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实验室挂代理宿舍免费上网折腾小记]]></title>
        <id>https://wizyoung.github.io/post/实验室挂代理宿舍免费上网折腾小记/</id>
        <link href="https://wizyoung.github.io/post/实验室挂代理宿舍免费上网折腾小记/">
        </link>
        <updated>2017-02-21T05:10:07.000Z</updated>
        <summary type="html"><![CDATA[<p>大学的网费还是比较贵的，自从研究生进入实验室后发现，实验室网段属于校园网的白名单，也就是说流量不计费。正好实验室主机安装了 Linux 系统，搭建一个代理服务，校园网连接使用不就免流量了么。</p>
<p>比较简单的方式是搭建一个 L2TP / IPsec-vpn 或者 shadowsocks 服务。</p>
]]></summary>
        <content type="html"><![CDATA[<p>大学的网费还是比较贵的，自从研究生进入实验室后发现，实验室网段属于校园网的白名单，也就是说流量不计费。正好实验室主机安装了 Linux 系统，搭建一个代理服务，校园网连接使用不就免流量了么。</p>
<p>比较简单的方式是搭建一个 L2TP / IPsec-vpn 或者 shadowsocks 服务。</p>
<!-- more -->
<blockquote>
<p>服务端平台: Ubuntu 16.04<br>
客户端平台: macOS</p>
</blockquote>
<h2 id="1-l2tp-ipsec-服务搭建">1. L2TP / IPsec 服务搭建</h2>
<h3 id="11-获取公网-ip-和端口转发">1.1 获取公网 IP 和端口转发</h3>
<p>实验室采用静态 IP，因此，进入路由器后台即可知道实验室网络公网 IP 地址。</p>
<p>由于 L2TP / IPsec 服务需要占用 500 和 4500 udp 端口，因此，我们首先要在路由器后端开放这两个端口。以 Padavan 固件为例 (其他路由器系统类似)，在端口转发里添加如下规则:</p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>源IP地址</th>
<th>端口范围</th>
<th>内网IP</th>
<th>本地端口</th>
<th>协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>udp500</td>
<td>*.*.*.*</td>
<td>500</td>
<td>主机局域网IP</td>
<td>500</td>
<td>Both</td>
</tr>
<tr>
<td>udp4500</td>
<td>*.*.*.*</td>
<td>4500</td>
<td>主机局域网IP</td>
<td>4500</td>
<td>Both</td>
</tr>
</tbody>
</table>
<h3 id="12-l2tp-ipsec-服务">1.2 L2TP / IPsec 服务</h3>
<p>最简单的 L2TP / IPsec VPN 搭建还是用 docker 比较方便。<br>
首先创建一个 <code>env</code> 文件存储 PSK 密钥、用户名和密码，该文件如下填写：</p>
<pre><code class="language-shell">VPN_IPSEC_PSK=自定义 PSK 密钥
VPN_USER=自定义用户名
VPN_PASSWORD=自定义密码
</code></pre>
<p>使用 hwdsl2/ipsec-vpn-server 镜像搭建服务:</p>
<pre><code class="language-shell">docker run \
    --name ipsec-vpn-server \
    --env-file ./vpn.env(替换为自己的 env 文件路径) \
    --restart=always \
    -p 500:500/udp \
    -p 4500:4500/udp \
    -d --privileged \
    hwdsl2/ipsec-vpn-server
</code></pre>
<p>上面 <code>--restart=always</code> 保证了服务开机、失败后自启动。</p>
<h3 id="12-macos-客户端设置">1.2 macOS 客户端设置</h3>
<p>进入 <code>设置</code> -&gt; <code>网络</code>，点击左下角的加号 <code>+</code>, 添加新的 VPN 连接:</p>
<figure data-type="image" tabindex="1"><img src="https://wizyoung.github.io/post-images/1581604645865.jpg" alt="" loading="lazy"></figure>
<p>在认证连接里面，用户认证的密码对应于上面的 <code>VPN_PASSWORD</code>，机器认证的密码对应于 <code>VPN_IPSEC_PSK</code>。</p>
<p>记得在高级选项里面勾选<strong>通过VPN连接发送所有流量</strong>，不然 VPN 连接后并不会进行流量转发，比较坑爹。</p>
<p>这时候点击<code>连接</code>后即可连上 VPN 免费上网了。建议设置里面勾选<code>在菜单栏中显示VPN状态</code>，方便在任务栏一键连接 VPN 并实时查看连接状态。</p>
<p>L2TP / IPsec VPN 的一个特点是，网络波动掉线后并不会重连，每次在电脑手动重连 VPN 还是比较麻烦的，因此我们可以利用 AppleScript 写一个脚本，实现掉线自动重连：</p>
<p>打开脚本编辑器，选择语言类型为 AppleScript，填入如下脚本：</p>
<pre><code class="language-javascript">on idle
	tell application &quot;System Events&quot;
		tell current location of network preferences
			set myConnection to the service &quot;VPN (L2TP)&quot;
			if myConnection is not null then
				if current configuration of myConnection is not connected then
					connect myConnection
				end if
			end if
		end tell
		return 30
	end tell
end idle
</code></pre>
<p>上面 <code>set myConnection to the service</code> 后对应的系统设置里面 VPN 连接的名字，默认是 <code>VPN (L2TP)</code>，注意这里括号前有一个空格。</p>
<p>填写完毕后存储为应用程序即可，如下图所示：<br>
<img src="https://wizyoung.github.io/post-images/1581605403648.jpg" alt="" loading="lazy"></p>
<p>双击保存的 app 后即会自动掉线重连 VPN。</p>
<h2 id="2-shadowsocks-服务搭建">2 Shadowsocks 服务搭建</h2>
<p>shadowsocks 的搭建就比较简单了，这里安装 Python 版的 shadowsocks 服务:</p>
<pre><code class="language-shell">sudo pip install shadowsocks
</code></pre>
<p>新增配置文件，以新增 <code>/etc/shadowsocks.json</code> 为例，里面填写:</p>
<pre><code class="language-json">{
    &quot;server&quot;:&quot;::&quot;,
    &quot;local_address&quot;:&quot;127.0.0.1&quot;,
    &quot;local_port&quot;:6153,
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;rc4-md5&quot;,
    &quot;server_port&quot;:443,
    &quot;password&quot;:&quot;password&quot;,
    &quot;fast_open&quot;:false
}
</code></pre>
<p>server填写 &quot;::&quot; 可以同时转发 ipv4 和 ipv6。考虑到我服务端本地还要运行一个 shadowsocks client 实例，因此为了避免冲突，local_port 不选 1080，而是随便选了一个 6153 端口。另外，为了提高性能，加密方式选用 rc4-md5。由于这里服务端开启了 443 端口，因此路由器记得开放 443 端口转发权限。</p>
<p>开启 shadowsocks 服务：</p>
<pre><code class="language-shell">sudo ssserver -c /etc/shadowsocks.json -d start
</code></pre>
<p>可以利用 systemctl 添加一个开机自启动服务，使 ss 时刻后台运行。在 <code>etc/systemd/system</code> 下创建 <code>ss.service</code> 文件，内容填写:</p>
<pre><code class="language-shell">[Unit]
Description=shadowsocks server
After=network.target

[Service]
Type=simple
Restart=always

ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks.json

[Install]
WantedBy=multi-user.target
</code></pre>
<p>执行以下两条指令使服务生效:</p>
<pre><code class="language-shell">sudo systemctl enable ss.service
sudo systemctl start ss.service
</code></pre>
<p>客户端中随便一个 ss 客户端填入对应的 IP、端口、加密方式、密码就 OK 了。以 Surge 为例，填写以下配置就行：</p>
<pre><code class="language-shell">代理名称 = ss, 公网 IP, 443, encrypt-method=rc4-md5, password=password
</code></pre>
<p>千兆带宽下蹭网就是爽哈哈哈~</p>
<figure data-type="image" tabindex="2"><img src="https://wizyoung.github.io/post-images/1581609375779.jpg#s70" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[极路由 1s 刷老毛子 Padavan 固件教程]]></title>
        <id>https://wizyoung.github.io/post/极路由1s刷老毛子Padavan固件教程/</id>
        <link href="https://wizyoung.github.io/post/极路由1s刷老毛子Padavan固件教程/">
        </link>
        <updated>2017-02-12T02:39:00.000Z</updated>
        <summary type="html"><![CDATA[<p>不得不说，极路由官方固件实在太烂，难以忍受，网上普遍反应的间歇跳 Ping，网络不稳定需要重启等问题我都遇到过，更让人烦躁的是重启速度极慢(往往需要 3 分钟之久)，断网状态下手机 APP 竟然不能访问后台以及断网时网页版后台各种抽风(每次配置个路由中继要死的心都有了)等等诸如此类的问题。2015 年初以不到百元的价格买到的手头台极路由 1S，拥有 16 M 闪存，128 M 内存如此强大的配置，却配着如此垃圾的固件实在可惜，因此今天花了点时间将它刷成了老毛子 Padavan 固件。</p>
]]></summary>
        <content type="html"><![CDATA[<p>不得不说，极路由官方固件实在太烂，难以忍受，网上普遍反应的间歇跳 Ping，网络不稳定需要重启等问题我都遇到过，更让人烦躁的是重启速度极慢(往往需要 3 分钟之久)，断网状态下手机 APP 竟然不能访问后台以及断网时网页版后台各种抽风(每次配置个路由中继要死的心都有了)等等诸如此类的问题。2015 年初以不到百元的价格买到的手头台极路由 1S，拥有 16 M 闪存，128 M 内存如此强大的配置，却配着如此垃圾的固件实在可惜，因此今天花了点时间将它刷成了老毛子 Padavan 固件。</p>
<!-- more -->
<blockquote>
<p>注意：本教程极路由版本为 HC5661A，其它版本需要下载对应的 Breed 和 Padavan 固件，方法通用。</p>
</blockquote>
<h2 id="1-开启开发者模式">1. 开启开发者模式</h2>
<p>所谓的开启开发者模式其实就是 Root。操作步骤为：浏览器输入 192.168.199.1 进入后台管理界面，在云平台里面选择“路由器信息”，在页面的底部点击 + 号进入高级设置，里面点击蓝色的申请按钮申请开通开发者模式，后面按操作提示完成认证即可。</p>
<h2 id="2-刷入-breed">2. 刷入 Breed</h2>
<p>首先要刷入<strong>引导加载器</strong> Bootloader，它是用于加载操作系统的程序，现在的 BIOS、UEFI、GRUB 都叫Bootloader。这里要刷入的 Breed 也是 Bootloader 的一种，由网友 hackpascal 开发。</p>
<p>首先去<a href="http://www.right.com.cn/forum/thread-161906-1-1.html">官方Breed发布界面</a>找到路由器对应的 Breed 版本，找到相应的下载链接。我这里找到的是 2017-2-11 发布的最新版本（好像后续更新后下载链接都不变），下载链接为：http://breed.hackpascal.net/breed-mt7628-hiwifi-hc5661a.bin</p>
<p>Mac 平台下打开终端(Win 可使用 Putty)输入：</p>
<pre><code class="language-powershell">ssh -p 1022 root@192.168.199.1
</code></pre>
<p>然后键入密码登陆。</p>
<p>然后下载 Breed：</p>
<pre><code class="language-powershell">wget http://breed.hackpascal.net/breed-mt7628-hiwifi-hc5661a.bin
</code></pre>
<p>刷入Breed：</p>
<pre><code class="language-powershell">mtd write breed-mt7628-hiwifi-hc5661a.bin u-boot
</code></pre>
<p>执行完后启动 Breed：断电，用卡针顶住复位键不放，上电大约5秒后松开复位键，路由器插上网线连接 PC，访问 192.168.1.1 进入 Breed 节面(如下图)：</p>
<figure data-type="image" tabindex="1"><img src="https://wizyoung.github.io/post-images/1581602902960.png#s70" alt="" loading="lazy"></figure>
<h2 id="3-刷入-padavan-固件">3. 刷入 Padavan 固件</h2>
<p>建议在刷入固件之前先对旧固件备份：点击上图左侧“固件备份”，备份所有。</p>
<p>去恩山论坛固件<a href="http://www.right.com.cn/forum/thread-161324-1-1.html">发布界面</a>找到路由器对应的固件版本下载，我这里下载的是 2017-2-11 更新的<code>RT-AC1200-GPIO-38-ji1A-128M_3.4.3.9-099.trx</code> 文件。</p>
<p>在上图点击“固件更新”，选择刚才下载的固件，上传，更新，等待进度条走满刷机完成即可。</p>
<p>刷入后，新的默认网关为192.168.123.1，管理员默认账号和密码为：admin / admin，WIFI 默认 ssid 和密码为 PDCN / 1234567890。</p>
<p>至此 Padavan 就刷机完成！如下图：</p>
<figure data-type="image" tabindex="2"><img src="https://wizyoung.github.io/post-images/1581602951337.png#s90" alt="" loading="lazy"></figure>
<h2 id="4-相关问题">4. 相关问题</h2>
<h3 id="41-无线中继模式下的相关问题">4.1 无线中继模式下的相关问题</h3>
<p>（1）中继显示连接失败：部分路由其兼容性问题导致，尝试更改 WIFI 信道带宽为 20 MHz</p>
<p>（2）无线 AP 工作模式选择: AP-Client + AP 时，上级主路由和本路由在同一网段，因此从192.168.123.1 无法进入后台管理界面，应输入 192.168.1.1 进入上级主路由后台界面找到本路由分配的 LAN IP 再从该 IP 进入。比如从上图可看出，我的 LAN IP 为 192.168.1.239，不再是192.168.123.1。</p>
<h3 id="42-校园网使用-ipv6">4.2 校园网使用 IPv6</h3>
<p>北航使用 Native DHCPv6 协议，好像北邮等高校也是。</p>
<p>路由器<code>外部网络</code>-&gt;<code>IPv6设置</code>那里连接类型选 Native DHCPv6, 下面几个开关全打开：</p>
<figure data-type="image" tabindex="3"><img src="https://wizyoung.github.io/post-images/1581603000498.png" alt="" loading="lazy"></figure>
<p>然后ssh进入后台执行以下三条命令即可[^1]：</p>
<pre><code class="language-powershell">modprobe ip6table_mangle
ebtables -t broute -A BROUTING -p ! ipv6 -j DROP -i eth2.2
brctl addif br0 eth2.2
</code></pre>
<p>命令解释：</p>
<blockquote>
<ol>
<li>第一条命令：加载 ip6table_mangle 内核模块。</li>
<li>第二条命令：阻止内网对外网所有非 IPV6 流量的访问，即 IPV4 流量依然通过 NAT。</li>
<li>第三条命令：让 WAN 口（eth2.2）成为内网（br0）的一个端口，这样做使得局域网内的主机与外网处于一个广播域，可以收到校园网网关的路由配置信息，每一台主机便可以得到一个全局的 IPv6 地址。</li>
</ol>
</blockquote>
<p>执行以上命令后，校园网会暂时中断一会儿，稍等片刻即可(我有时候偶尔等了好几分钟后 IPV6 才连上)</p>
<p>考虑到每次重启路由器都要执行以上命令，因此我将以上三条命令写入路由器开机执行脚本里面：</p>
<p>将以上三跳命令复制到<code>高级设置</code>—<code>自定义信息</code>—<code>脚本</code>—<code>在路由器启动后执行</code>里面即可</p>
<h3 id="43-ss-功能不能使用">4.3 ss 功能不能使用</h3>
<p>该固件 ss 部分有一个设置的提示有极大的误导性，见下图：</p>
<figure data-type="image" tabindex="4"><img src="https://wizyoung.github.io/post-images/1581603045695.png#s70" alt="" loading="lazy"></figure>
<p>这里的中括号不能填写进去！！！我一度以为这个固件的ss模块有bug，直到某一天删掉了这个中括号就好了~</p>
<hr>
<p>参考资料</p>
<p>[1]<a href="http://qydw.blogspot.jp/2016/11/padavanipv6ipv6.html">三个命令解决Padavan路由器内网IPV6访问（适用于IPV6无需认证的网络）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的 Mac 软件列表]]></title>
        <id>https://wizyoung.github.io/post/我的Mac软件列表/</id>
        <link href="https://wizyoung.github.io/post/我的Mac软件列表/">
        </link>
        <updated>2017-01-28T14:54:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文更新于 2020.1.13</p>
</blockquote>
<p>作为 macOS 忠实用户，自从我 2015 年抛弃 Windows 投入 macOS 阵营来，除偶尔需要游戏不方便外，整体的体验还是较之前 Windows 时代好不少，究其原因，无非三点：（1） macOS 是类 Unix 系统，作为商业软件，整体的桌面环境又比一般 Linux 发行版好太多；（2）整体的软件生态环境比 Windows 好一点，大量的优质软件给整个平台带了良好的用户体验，再和 iOS 结合非常舒适。</p>
<p>由于每年的需要不一致，这几年我电脑上的软件列表一直在发生变化，大概整理了一下截至 2020 年初我经常使用的软件列表：</p>
<h2 id="1-效率工具">1 效率工具</h2>
<ol>
<li>HomeBrew: 一个好用的包管理工具，简单易用。我想主要的缺点是对旧版本软件的支持不太好吧，这一点比不上 apt-get 之类的工具，但大部分条件下够用了。</li>
<li>iTerm 2 &amp; oh-my-zsh: 比较好用的终端，配合 oh-my-zsh 功能强大颜值又比较高，相信大部分的开发者都是使用的这套配置吧。</li>
<li>Alfred: workflow 式的效率工具，配合各式插件功能强大，可以看成增强版 Spotlight 吧，日常工作生活中自己写了很多 workflow 进行自动化操作，还是比较方便的。</li>
<li>Popclip: 鼠标选中文本后弹出的工具条，可进行多种效率操作。基本是日常使用频率最高的小软件了，自己也开发了不少小工具，比如谷歌翻译的插件 <a href="https://github.com/wizyoung/googletranslate.popclipext">googletranslate.popclipext</a>。</li>
</ol>
<h2 id="2-coding">2 Coding</h2>
<ol>
<li>IDE 系列：目前在用的比较“重”的 IDE: Xcode, Pycharm, IntelljJ IDEA。</li>
<li>Sublime &amp; VS Code: Sublime 打开速度确实快，当做默认文本编辑器了，以及各种语言的 REPL 环境；VS Code 写写日常代码或者小工程，说到 VS Code 就不得不提远程端的 <a href="https://github.com/cdr/code-server">code-server</a>，单文件可执行文件，扔到 Linux 主机，开放一个端口，本地电脑打开浏览器输入地址就可以运行，远程调用代码，确实好用 （比如公司主机要通过层层跳板机连接，但是可以随便开放本地端口，就可以用这个替代 vim 呀，前提是公司允许）。</li>
<li>Code Runner：测试小代码片段，随开随用。去年找工作刷 LeetCode 时经常用它作本地调试。</li>
<li>Dash：全语言文档手册速查，离线查看。</li>
<li>Tower：比较喜欢的一个 Git 客户端。</li>
<li>Expression：测试正则表达式。</li>
</ol>
<h2 id="3-网络">3 网络</h2>
<ol>
<li>Surge: 无痛爬墙，简单网络抓包，好用到没朋友。这几年来一直自己维护了一套规则，经过了时间的考验，在网络上比较丝滑。Surge 提供的 snell 专有协议也比较不错，简单高性能，敏感时期 SS 都挂的时候 snell 比较稳定 (小众就是好呀)。</li>
<li>Charles: 偶尔抓抓包。</li>
<li>IP Scanner: 当网络很复杂时，比如多层路由中继，它能一个不落全扫描出来。</li>
<li>Transmit: 比较好用的 SFTP 客户端，最好用的功能是一键在终端切换到远程路径下，在同类软件中简直无敌。同时支持挂载 google drive, webdav, backblaze b2 等诸多协议。</li>
<li>BestTrace: IPIP 出品，用来看看 VPS 国际线路，是直连还是绕了地球一大圈。</li>
<li>GoodSync：局域网文件同步和备份。</li>
</ol>
<h2 id="4-知识管理">4 知识管理</h2>
<ol>
<li>Keep It: 文档管理与同步工具。以前用 DEVONthink，功能确实强大，然而有点过于复杂，同步机制做的也不 OK，iOS 至今是个半残（即使我付费购买后又进一步解锁了内购），抛弃了。Keep It 虽然功能上不如 DEVONthink，然而基础功能经过一段比较长时间的验证发现完全够用，尽管软件有点小瑕疵，但是作者一直高频更新着，确实一次比一次好。</li>
<li>Quiver：在经历了印象笔记，为知笔记，有道云笔记，notion，OneNote 等众多笔记软件后，还是选了Quiver。其实大家好评如潮的 notion 的 block 模式不就是抄的 quiver 么，15 年我用 quiver 时 quiver 就提出了 block 模式。与主流完全相反，我抵制 markdown 记笔记，尤其对理工科生而言，大量的图片、代码和公式，用 markdown 往往让人迷失在格式和排版中，混合 block 才是正解。可惜 quiver 是 one-man 软件，给作者反馈了大量意见，从 2018 年底开始就不断跟我说版本 4 要出来了，然而这都 2020 年了。。。独立开发不易，希望作者加把劲吧，再这样下去 notion 的离线模式做好了，quiver 可能就要消失在历史的长河中了。</li>
<li>系统自带备忘录：自带备忘录记录零碎想法真的超级好用呀~</li>
<li>OmniGraffle：写 Paper 画个结构图、流程图啥的比较好用。对于公式，配合免费的 LaTeXIT，输入 LaTeX 公式，把生成的矢量 PDF 直接拖入到 OmniGraffle 即可解决 OmniGraffle 无法原生支持数据公式的问题。</li>
<li>Texpad：实时更新的 LaTeX 编辑器，估计是所有平台上最好用的 LaTeX 编辑器了吧。</li>
</ol>
<h2 id="5-系统增强">5 系统增强</h2>
<ol>
<li>Jitouch + BetterTouchTool: 触摸板增强，感觉还是两个软件配合起来用比较顺滑。</li>
<li>Bartender： 任务栏图标太多，用它整理，并去掉讨厌的 Siri 和 Spotlight 图标等。</li>
<li>Paste：颜值爆表的剪切板历史记录软件，快捷键呼出，简直不能更方便。</li>
<li>iStat Menus：任务栏上的多功能 Monitor。日常用来看网速，应用联网情况和 CPU、内存占用，颜值高又好用（早期版本 6 的 beta 出来时给软件反馈了些 bug 并修改了一些汉化问题，免费送了我一份授权hhh）</li>
<li>1Password：高效、安全、便捷地管理密码的完美方案，支持 Touch ID（可惜 15 款本本没有），已经离不开。</li>
<li>DiasyDisk：饼状图分析磁盘占用。</li>
<li>App Cleaner &amp; Uninstaller：软件卸载，目前觉得还是它卸载最干净。</li>
<li>Easy New File: 任意地方右键一键在当前路径打开 iTerm。</li>
<li>Coherence Pro：基于 chrome 的网页打包成 app 的软件，资源占用比原生 chrome 小很多。</li>
<li>Karabiner-Elements：键位魔改与增强。</li>
<li>Keyboard Maestro：基于键盘的自动化工具。我用来消除剪贴板格式，和一键填充 1password 主密码 (通过调用 keychain 的方式)。</li>
<li>MacUpdater: 在一个地方检测整个系统所有软件的更新。</li>
<li>One Switch：任务栏常驻软件，一键开关深色模式、防止睡眠等等。</li>
<li>Parallels Desktop：最好用的虚拟机软件。尤其是 Linux 的 headless 模式，内存占用极低，性能也比较高。</li>
</ol>
<h2 id="6-图像影音">6 图像影音</h2>
<ol>
<li>PP 鸭：最好用的图片压缩软件了吧，可惜不提供 cli 接口。</li>
<li>Xnip：截图软件中在功能和重量之间权衡最好的了吧。</li>
<li>PixelMator: 相比 PS 很轻的全能图像编辑软件。</li>
<li>IINA：视频播放器。</li>
<li>QQ 音乐 + 腾讯视频 + 爱奇艺 + 优酷：日常影音娱乐。</li>
</ol>
<h2 id="7-社交网络">7 社交网络</h2>
<ol>
<li>QQ + 微信：微信推荐使用 <a href="https://github.com/MustangYM/WeChatExtension-ForMac">微信小助手</a> 插件，免认证登录和防撤回，比较方便。</li>
<li>Telegram：好吧，我用来当跨平台文本和文件传输同步，以及链接收藏。在学校的时候，还写过一个 bot 监控老板在不在实验室 hhh。</li>
<li>Maipo：第三方微博客户端。</li>
</ol>
]]></content>
    </entry>
</feed>